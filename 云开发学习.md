# 1.0云开发学习

本地项目地址 D:\Study\云音乐

# 2.0云开发的优势

```
1.云函数支持本地调试，调试云端和调试前端代码是一样的，做到了全栈开发模式

2.可以快速上线

3.可以专注核心业务

4.减少前后端沟通成本

5.无需运维，节约成本

```

## 2.1云开发提供了哪些能力

```
1.云函数:在云端运行的代码。微信私有协议天然鉴权 （开发者可以很方便的获取到用户的openId，云函数相当于小程序的后端部分）
2.云数据库：一个既可以在小程序端操作又可以在云函数中操作的JSON数据库
3.云存储：在云端存储文件，可以在云端控制台可视化管理
4.云调用：基于云函数免鉴权使用小程序开放接口的能力
5.HTTP API：使用HTTP API开发者可以在已有服务器上访问云资源，实现与云开发的互通
```

## 2.2开通云开发

1.[https://mp.weixin.qq.com](https://mp.weixin.qq.com/)登录微信公众平台获取自己的appid

2.点击微信开发工具的左上角云开发按钮

3.点击后的弹窗=》创建环境 =》声明环境名称和环境ID后点击确定即可

## 2.3初始化项目

1.当创建完云环境后可以看见第一个文件夹使用 | 分割后面是对应环境的名称

2.miniprogram目录中的app.js是项目的配置文件，其中env代表当前对应的环境，具体可打开云开发控制台查看（设置=》环境设置=》右侧即可查看）

3.app.js中  traceUser: true  是否记录每个访问小程序的用户，并且以倒叙的形式显示

## 2.4配置tabbar

- 在app.json中输入list即可，之后按照需求配置
- color文本颜色 selectedColor 选中的文本颜色

```
  "tabBar": {
    "color":"#474747",
    "selectedColor":"#d43c43",
    "list": [
      {
      "pagePath": "pages/playlist/playlist",
      "text": "音乐",
      "iconPath": "images/music.png",
      "selectedIconPath": "images/music-actived.png"
    },
      {
      "pagePath": "pages/blog/blog",
      "text": "发现",
      "iconPath": "images/blog.png",
      "selectedIconPath": "images/blog-actived.png"
    },
      {
      "pagePath": "pages/blog/blog",
      "text": "我的",
      "iconPath": "images/profile.png",
      "selectedIconPath": "images/profile-actived.png"
    }
    ]
  },
```

## 2.5配置轮播图

- 注意获取变量需要用双大括号包裹才可以拿到值

- 不加就会变成循环这个字符串

- widthFix代表宽度占满，高度自适应，配合图片宽度100%可以完整显示轮播图

```vue
<swiper indicator-dots="true" autoplay="true" interval="2000" duration="1000">
  <block wx:for="{{swiperImgUrls}}" wx:key="*this">
    <swiper-item>
      <image src="{{item.url}}" mode="widthFix"></image>
    </swiper-item>
  </block>
</swiper>
```

## 2.6组件化的好处

- 高内聚：保证一个段一个单元的代码来解决一个需求
- 低耦合：组件和组件之间减少耦合性，组件相对独立，增强组件的复合型
- 单一职责
- 避免过多参数

## 2.7自定义播放列表组件

1. 注册组件，在components文件夹下新建playlistitem组件

```vue
<view class="playlist-container">
  <image src="{{playlist.picUrl}}" class="playlist-img"></image>
  <text class="playlist-playcount">{{playlist.playCount}}</text>
  <view class="playlist-name">{{playlist.name}}</view>
</view>
```

2. 接受父组件传过来的参数对象

```
  properties: {
    playlist: {
      type: Object,
      value: {}
    }
  },

```

3.写入样式

注意由于每个组件占一行的三分之一，因此设定宽度来实现这个效果而不是flex：1

父组件设置 display:flex 和 flex-wrap:wrap换行即可



右上角的耳机图标的设置：给容器设置了背景图片，不重复，位置为left和center，也就是靠左和居中

```css
.playlist-container {
  width: 220rpx;
  position: relative;
  padding-bottom: 20rpx;
}

.playlist-img {
  width: 100%;
  height: 220rpx;
  border-radius: 6rpx;
}

.playlist-playcount {
  font-size: 24rpx;
  color: #fff;
  text-shadow: 1px 0 0 rgba(0, 0, 0, 0.15);
  position: absolute;
  right: 10rpx;
  top: 4rpx;
  padding-left: 26rpx;
  background: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMiAyMCI+PGcgb3BhY2l0eT0iLjE1Ij48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGZpbGw9IiMwNDAwMDAiIGQ9Im0yMiAxNi43NzdjMCAxLjIzMy0xLjEyMSAyLjIzMy0yLjUwNiAyLjIzMy0xLjM4NCAwLTIuNTA2LTEtMi41MDYtMi4yMzN2LTIuNTUzYzAtMS4yMzQgMS4xMjItMi4yMzMgMi41MDYtMi4yMzMuMTc0IDAgLjM0My4wMTcuNTA2LjA0NnYtMS4zN2gtLjAzM2MuMDE3LS4yMi4wMzMtLjQ0MS4wMzMtLjY2NiAwLTQuNDE4LTMuNTgyLTgtOC04LTQuNDE4IDAtOCAzLjU4Mi04IDggMCAuMjI1LjAxNi40NDYuMDM0LjY2NmgtLjAzNHYxLjM3Yy4xNjMtLjAyOS4zMzMtLjA0Ni41MDUtLjA0NiAxLjM4NCAwIDIuNTA2Ljk5OSAyLjUwNiAyLjIzM3YyLjU1M2MwIDEuMjMzLTEuMTIyIDIuMjMzLTIuNTA2IDIuMjMzcy0yLjUwNS0uOTk5LTIuNTA1LTIuMjMzdi0yLjU1M2MwLS4yNTguMDU5LS41MDEuMTQ4LS43My0uMDg1LS4xNDgtLjE0OC0uMzEtLjE0OC0uNDkzdi0yLjY2N2MwLS4wMjMuMDEyLS4wNDMuMDEzLS4wNjctLjAwNC0uMDg4LS4wMTMtLjE3Ni0uMDEzLS4yNjYgMC01LjUyMyA0LjQ3Ny0xMCAxMC0xMCA1LjUyMyAwIDEwIDQuNDc3IDEwIDEwIDAgLjA5LS4wMDkuMTc4LS4wMTQuMjY2LjAwMi4wMjQuMDE0LjA0NC4wMTQuMDY3djJjMCAuMzA2LS4xNDUuNTY5LS4zNi43NTMuMjI0LjMzNC4zNi43Mi4zNiAxLjEzOHYyLjU1MiIvPjwvZz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGZpbGw9IiNmZmYiIGQ9Im0yMCAxNi43NzdjMCAxLjIzMy0xLjEyMSAyLjIzMy0yLjUwNiAyLjIzMy0xLjM4NCAwLTIuNTA2LTEtMi41MDYtMi4yMzN2LTIuNTUzYzAtMS4yMzQgMS4xMjItMi4yMzMgMi41MDYtMi4yMzMuMTc0IDAgLjM0My4wMTcuNTA2LjA0NnYtMS4zN2gtLjAzM2MuMDE3LS4yMi4wMzMtLjQ0MS4wMzMtLjY2NiAwLTQuNDE4LTMuNTgyLTgtOC04LTQuNDE4IDAtOCAzLjU4Mi04IDggMCAuMjI1LjAxNi40NDYuMDM0LjY2NmgtLjAzNHYxLjM3Yy4xNjMtLjAyOS4zMzMtLjA0Ni41MDUtLjA0NiAxLjM4NCAwIDIuNTA2Ljk5OSAyLjUwNiAyLjIzM3YyLjU1M2MwIDEuMjMzLTEuMTIyIDIuMjMzLTIuNTA2IDIuMjMzcy0yLjUwNS0uOTk5LTIuNTA1LTIuMjMzdi0yLjU1M2MwLS4yNTguMDU5LS41MDEuMTQ4LS43My0uMDg1LS4xNDgtLjE0OC0uMzEtLjE0OC0uNDkzdi0yLjY2N2MwLS4wMjMuMDEyLS4wNDMuMDEzLS4wNjctLjAwNC0uMDg4LS4wMTMtLjE3Ni0uMDEzLS4yNjYgMC01LjUyMyA0LjQ3Ny0xMCAxMC0xMCA1LjUyMyAwIDEwIDQuNDc3IDEwIDEwIDAgLjA5LS4wMDkuMTc4LS4wMTQuMjY2LjAwMi4wMjQuMDE0LjA0NC4wMTQuMDY3djJjMCAuMzA2LS4xNDUuNTY5LS4zNi43NTMuMjI0LjMzNC4zNi43Mi4zNiAxLjEzOHYyLjU1MiIvPjwvc3ZnPg==) no-repeat;
  background-position: left;
  background-size: 26rpx;
}

.playlist-name {
  font-size: 26rpx;
  line-height: 1.2;
  padding: 2px 0 0 6px;
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 2;
  overflow: hidden;
  text-overflow: ellipsis;
}

```

## 2.8转换组件上的播放数量

定义一个方法来转换

- 首先把小数点后的数字去掉
- 如果小于6位则不操作
- 如果大于等于6小于等于8即在一亿以下，十万以上则把万以下的数字切出来例如15422切出5422，切的数量根据传的point决定
- 返回传入数字除以10000并取整，可得万的数量，拼接上刚才切出的数字则可得 xx.xx万

```javascript
    // 根据传入的数值把数字转为带单位
    _tranNumber(num,point=2) {
      // 获取Num
      let newNum = num.toString().split(".")[0]
      if (newNum.length < 6) {
        return newNum
      } else if (newNum.length >= 6 && newNum.length <= 8) {
        let decimal = newNum.substring(newNum.length - 4, newNum.length - 4 + point)
        console.log(decimal,'decimal')
        return (parseFloat(parseInt(num / 10000) + '.' + decimal)) + '万'
      }
      else if (newNum.length > 8) {
        let decimal = newNum.substring(newNum.length - 8, newNum.length-8+point)
        return parseFloat(parseInt(num/100000000)+ '.' + decimal) + '亿'
      }
    }
```

observers是组件内部的属性，可以监听值的改变，因此监听传入的数量，并转化为可读格式后赋值给data内部的变量。注意不能在这里直接修改自己，不然会无限变化并监听变化造成死循环

```
  observers: {
    ["playlist.playCount"](val){
      console.log(val,'val')
      console.log(this._tranNumber(val,2),'@@@')
      // return this._tranNumber(val, 3)
      this.setData({
        _count: this._tranNumber(val, 2)
      })
    }
  },
```

# 3.0开发中的常见问题

## 3.1 wx:for循环

1. wx:for对应的数组/对象需要用 {{}} 双大括号包裹才可
2. wx:key 如果循环的数组是静态的，可以忽略，如果是动态的数组或者要对数组进行操作，则需要对应数组中的一个独一无二的属性，例如id



## 3.2Promise

1. promise.all 代表所有的请求都成功才会成功 ,但是不会阻止失败之后的任务的执行

   - 当文件上传的时候推荐使用，当所有的文件都上传成功才会执行回调

   ```
   Promise.all([promise请求,promise请求]).then(res=> {  console.log(res)  })
   ```


2. promise.race  代表有一个请求完成后就成功

   - 可以验证超时，把请求和一个定时器放在一起执行，如果定时器先执行说明请求超时（更慢）

   ```
   Promise.race([promise请求,promise请求]).then(res=> {  console.log(res)  })
   当其中一个请求完成就会
   ```


## 3.3云函数初体验

1. 新建一个云函数，推荐直接右键创建

2. ```
   安装依赖
   npm i request --save
   npm i request-promise --save
   ```

   调用接口发送请求

   - 注意需要先cloud.init()初始化
   - const db = cloud.database() 导入云数据库
   - 通过request-promise发送请求获取数据 ，前面要加上await
   - 获取到数据后需要JSON.parse（res）把返回的数据转换为对象，有时返回的是JSON字符串，因此用于保险
   - 获取到数据后通过数据库的add方法插入到云数据库中，注意方法前要加上 awiat  ( await db.collection("playlist").add )
   - 要想插入数据需要在add内部对象定义一个data才可插入数据，单独写add（{}）无效
   - 完成后上传到云端并在云端测试

   ```vue
   // 云函数入口文件
   const cloud = require('wx-server-sdk')
   
   cloud.init()
   
   const db = cloud.database()
   
   const rp = require("request-promise")
   
   const URL = 'http://musicapi.xiecheng.live/personalized'
   
   // 云函数入口函数
   exports.main = async (event, context) => {
     const wxContext = cloud.getWXContext()
     let playlist = await rp(URL).then(res=> {
       return JSON.parse(res).result
     })
     console.log(playlist)
     for (let i = 0; i < playlist.length;i++) {
       await db.collection("playlist").add({
         data: {
           ...playlist[i],
           createTime: db.serverDate()
         }
       }).then(res=>{
         console.log('插入成功')
       }).catch(err=> {
         console.log(err,'err')
       })
     }
     
   
     return {
       event,
       openid: wxContext.OPENID,
       appid: wxContext.APPID,
       unionid: wxContext.UNIONID,
     }
   }
   ```

## 3.4新增去重操作

- 注意  db.collection("playlist").get()  获取到的数据需要再 .data才能获取到要操作的数组！

```vue
// 云函数入口文件
const cloud = require('wx-server-sdk')

cloud.init()

const db = cloud.database()

const rp = require("request-promise")

const URL = 'http://musicapi.xiecheng.live/personalized'

const getDb = db.collection("playlist")

// 云函数入口函数
exports.main = async(event, context) => {
  // 获取数据库中的已有数据
  let list = await getDb.get()
  console.log(list, '输出list')
  // 定义一个数组用于插入数据
  let newArr = []
  // 接口获取的新数据
  let playlist = await rp(URL).then(res => {
    return JSON.parse(res).result
  })
  for (let i = 0; i < playlist.length; i++) {
    let flag = true
    for (let j = 0; j < list.data.length; j++) {
      if (playlist[i].id === list.data[i].id) {
        flag = false
      }
    }
    if (flag) {
      newArr.push(playlist[i])
    }
  }

  console.log(newArr, '输出newArr')
  for (let i = 0; i < newArr.length; i++) {
    await getDb.add({
      data: {
        ...newArr[i],
        createTime: db.serverDate()
      }
    }).then(res => {
      console.log('插入成功')
    }).catch(err => {
      console.log(err, 'err')
    })
  }


  return
}
```

## 3.5分段取出数据库的所有数据

- 云数据库有限制，一次只能取出100条数据

- 因此获取总数，然后分次数拿到每次返回的promise对象

- 通过promise.all 和 reduce方法拼接返回的参数

  ```vue
    // 获取数据库中的已有数据
    let countResult = await getDb.count()
    // 拿到数据总数
    let total = countResult.total
    console.log(total,'total')
    // 获取的次数
    let batchTimes = Math.ceil(total/10)
    let tasks = []
    for (let i=0;i<batchTimes;i++) {
      // 这里不加await因为promise.all需要 promise对象
      let promise = getDb.skip(i*MAX_LIMIT).limit(MAX_LIMIT).get()
      tasks.push(promise)
    }
    let list = {
      data: []
    }
    console.log(tasks, '输出tasks')
    // 说明数据库不为空
    if (tasks.length > 0) {
      // await获取Promise.all的结果
      list = (await Promise.all(tasks)).reduce((acc,cur)=> {
        return {
          data: acc.data.concat(cur.data)
        }
      })
    }
    console.log(list,'输出list')
  ```

  ### 3.6触发器的使用

  - 触发器可以设置在某个时间点调用云函数

  - 在云函数的目录下新建conifg.json文件，写入下列代码

    ```
    {
      "triggers": [
        {
          "name": "myTrigger",
          "type": "timer",
          "config": "0 0 10,14,16,23 * * * *"
        }
      ]
    }
    ```

    完成后必须上传触发器才可生效

    config对应的是时间的格式 具体参考

    <https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/functions/triggers.html>

    本次含义为 每天的10点2点4点半夜11点触发一次

## 3.7获取音乐的云函数

- 调用定义的音乐云函数

- event就是你传入的data对象

- ```
  // 云函数入口文件
  const cloud = require('wx-server-sdk')
  
  cloud.init()
  
  // 云函数入口函数
  exports.main = async(event, context) => {
    // 获取音乐数据
    return await cloud.database().collection('playlist').skip(event.start).limit(event.count).orderBy('createTime', 'desc').get().then(res => {
      return res
    })
  
  }
  ```

  在页面的js中应用

```javascript
  _getPlayList() {
    wx.showLoading({
      title: '玩命加载中~',
    })
    // 获取音乐列表,start动态根据数组的长度变化
    wx.cloud.callFunction({
      name: 'music',
      data: {
        start: this.data.playlist.length,
        count: MAX_LIMIT
      }
    }).then(res => {
      console.log(res, '输出结果')
      this.setData({
        playlist: this.data.playlist.concat(res.result.data) 
      })
      // 请求完成隐藏下拉小点
      wx.stopPullDownRefresh()
      wx.hideLoading()
    }).catch(err => {
      wx.hideLoading()
      console.log(err, 'err')
    })
  },
```

## 3.8使用tcb-router管理云函数

- 为了解决云函数上限50个，因此使用tcb-router来管理相同类型的云函数

- 安装tab-router   npm i tcb-router --save

- 新建tabRouter云函数

- const app = new TcbRouter({event}) 必须传入event不然返回值为空

- app.router 定义路由

- 必须返回   return app.serve()

- 调用方法

  ```javascript
      wx.cloud.callFunction({ 
        name: 'tcbRouter',
        data: {
        // 路由名称
          $url: 'music'
        },
      }).then(res=> { 
        console.log(res,'res')
      })
  ```



  ```javascript
  // 云函数入口文件
  const cloud = require('wx-server-sdk')
  const TcbRouter = require('tcb-router')
  
  cloud.init()
  
  // 云函数入口函数
  exports.main = async(event, context) => {
    // 传入event参数，这样tab就会自动处理参数的转发
    const app = new TcbRouter({event})
  
    app.use(async(ctx, next) => {
      ctx.data = {}
      ctx.data.openId = event.userInfo.openId
      ctx.data.event = event
      await next()
    })
  
    app.router('music', async(ctx, next) => {
      ctx.data.musicName = '义勇军进行曲'
      await next()
    }, async(ctx, next) => {
      ctx.data.musicType = '国歌'
      ctx.body = {
          data: ctx.data
        }
    })
  
    app.router('movie', async(ctx, next) => {
      ctx.data.movieName = "千与千寻"
      await next()
    }, async(ctx, next) => {
      ctx.data.movieType = "日漫"
      ctx.body = {
        data: ctx.data
      }
    })
  
    return app.serve()
  }
  ```


## 3.9tcb-router的简单使用

- 云函数使用tcb-router

- 安装导入 tcb-router 后必须初始化并传入事件对象

- 最后要 返回 app.serve ()

  ```javascript
  
  // 云函数入口函数
  exports.main = async(event, context) => {
    const app = new TcbRouter({
      event
    })
    // 全局中间件
    app.use(async(ctx, next) => {
      await next()
    })
    app.router('music', async(ctx, next) => {
      // 获取音乐数据
      ctx.body = await cloud.database().collection('playlist').skip(event.start).limit(event.count).orderBy('createTime', 'desc').get().then(res => {
        return res
      })
      await next()
    })
  
    // 获取音乐数据
    // return await cloud.database().collection('playlist').skip(event.start).limit(event.count).orderBy('createTime', 'desc').get().then(res => {
    //   return res
    // })
    return app.serve()
  }
  ```

  使用该云函数

  - 如果使用了 tcb-router 的路由

  - 则需要传入 $url 对应路由的名称才可以调用

  ```javascript
      wx.cloud.callFunction({
        name: 'music',
        data: {
          $url:'music',
          start: this.data.playlist.length,
          count: MAX_LIMIT
        }
      }).then(res => {
        console.log(res, '输出结果')
        this.setData({
          playlist: this.data.playlist.concat(res.result.data) 
        })
        // 请求完成隐藏下拉小点
        wx.stopPullDownRefresh()
        wx.hideLoading()
      }).catch(err => {
        wx.hideLoading()
        console.log(err, 'err')
      })
  ```




## 3.10 小程序拓展

- 点击事件时对象的 target 和 currenttarget的区别
- target是你点击的元素，currenttarget是你绑定事件的元素

# 4.0播放页面制作

## 4.1进入歌曲列表时把数据存入本地

- 进入时会带入playlistId，也就是这个歌曲目录的id，根据云函数获取到对应的歌曲目录，并存入本地

```javascript
  _getMusicList() {
    wx.cloud.callFunction({
      name: 'music',
      data: {
        playlistId: this.data.playlistId,
        $url: 'musiclist'
      }
    }).then(res => {
      const pl = res.result.playlist
      this.setData({
        musiclist: pl.tracks,
        listInfo: {
          coverImgUrl: pl.coverImgUrl,
          name: pl.name
        }
      })
      this._setMusicList()
      wx.hideLoading()
      console.log(res, '输出结果')
    }).catch(err => {
      wx.hideLoading()
      console.log(err, '错误输出')
    })
  },
  _setMusicList() {
    // 同步的把歌曲列表数据存入本地
    wx.setStorageSync('musiclist', this.data.musiclist)
  },
```

## 4.2点击歌曲列表中的某一项高亮并进入详情页

- 定义一个列表组件，把歌曲列表的数据传入，循环渲染歌曲列表。
- 顶部高斯模糊背景加一张图片
- 相当于遮罩层在最下方，容器在遮罩层上方，设置了背景图片但是是模糊的，并且有透明度，因此可看到遮罩层的背景色
- 之后吧封面图片定位在上方即可

```html
// wxml
<view class="musiclist-container" style="background:url({{listInfo.coverImgUrl}}) no-repeat"></view>
<view class="detail-mask"></view>

// wxss
.musiclist-container {
  height: 320rpx;
  filter: blur(40rpx);
  opacity: 0.4;
  
}

/*遮罩层*/
.detail-mask {
  position: absolute;
  left: 0;
  top: 0;
  z-index: -1;
  height: 320rpx;
  width: 100%;
  background-color: #333;
}

```

## 4.3绘制歌曲详情页

- wxss
- 定义了一个遮罩层在最底部。设置一个容器背景图片为当前歌曲封面并设置高斯模糊。这两个容器都是覆盖整个页面的
- 上方指针动画是一张图片使用伪元素定位到上方的。当点击播放去除一个play 类。可以实现动画

```html
<view class="player-container" style="background:url({{picUrl}}) center/cover no-repeat"></view>
<view class="player-mask"></view>

<view class="player-info">
  <view class="player-disc {{isPlaying ? 'play' : ''}}">
    <image class="playerimg rotation {{isPlaying? '' : 'pauseRotate'}}" src="{{picUrl}}"></image>
  </view>
</view>
<view class="control">
  <text class="iconfont icon-shangyishoushangyige" bindtap="onPrev"></text>
  <text class="iconfont {{isPlaying ? 'icon-zanting1' : 'icon-bofang1'}}" bind:tap="togglePlaying"></text>
  <text class="iconfont icon-xiayigexiayishou" bindtap="onNext"></text>
</view>
```

```css
/* pages/player/player.wxss */

.player-container {
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  background: center;
  filter: blur(40rpx);
  opacity: 0.4;
  z-index: -1;
}

.player-mask {
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  right: 0;
  z-index: -2;
  background-color: #222;
}

.player-info {
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  text-align: center;
}

.player-disc {
  width: 592rpx;
  height: 592rpx;
  background: url(https://s3.music.126.net/mobile-new/img/disc.png?d3bdd1080a72129346aa0b4b4964b75f=) no-repeat center/contain;
  position: absolute;
  left: 50%;
  transform: translate(-50%, 140rpx);
  /* top: 50%; */
}

.player-disc::after {
  content: '';
  position: absolute;
  width: 192rpx;
  height: 192rpx;
  left: 266rpx;
  top: -144rpx;
  background: url(https://s3.music.126.net/m/s/img/needle.png?702cf6d95f29e2e594f53a3caab50e12) no-repeat center/contain;
  transform: rotate(-15deg);
  transform-origin: 24rpx 10rpx;
  transition: all 0.5s ease;
} 

.play.player-disc::after {
  transform: rotate(5deg);
}

.playerimg {
  width: 368rpx;
  height: 368rpx;
  border-radius: 50%;
  position: absolute;
  left: 50%;
  top: 50%;
  margin-top: -184rpx;
  margin-left: -184rpx;
  /* transform: translate(-50%, -50%); */
  /* transform: translate(30%,30%); */
}

/* 播放控件部分 */

.control {
  position: absolute;
  left: 50%;
  bottom: 8%;
  transform: translate(-50%);
  display: flex;
  align-items: center;
}

.control .iconfont {
  color: #e2e2e2;
}

.icon-shangyishoushangyige, .icon-xiayigexiayishou {
  font-size: 80rpx;
}

.icon-bofang1, .icon-zanting1 {
  font-size: 100rpx;
  margin: 0 28rpx;
}

.rotation {
    -moz-animation: rotation infinite linear 12s;
    -o-animation: rotation infinite linear 12s;
    -webkit-animation: rotation infinite linear 12s;
    animation: rotation infinite linear 12s ;
}

.pauseRotate {
  animation-play-state: paused;
}

@keyframes rotation {
  0% {
    transform: rotate(0deg)
  }
  100% {
    transform: rotate(360deg)
  }
}
```

## 4.4调用小程序音乐管理的api

- wx.getBackgroundAudioManager() 是小程序获取**全局唯一**的背景音频管理器
- <https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/wx.getBackgroundAudioManager.html>官方文档

```javascript
// pages/player/player.js
// 当数据不用于展示时最好不定义在data中
let musiclist = []
// 当前正在播放歌曲的index
let nowPlayingIndex = 0
// 获取全局唯一的背景音频管理器
const backgroundAudioManager = wx.getBackgroundAudioManager()
Page({

  /**
   * 页面的初始数据
   */
  data: {
    picUrl: '',
    isPlaying: false
  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function(options) {
    console.log(options, '@@')
    nowPlayingIndex = options.index
    // 获取本地存储的数据
    musiclist = wx.getStorageSync('musiclist')
    this._loadMusicDetail(options.musicId)
  },
  // 切换播放与暂停状态
  togglePlaying() {
    console.log(this.data.isPlaying, '点击')
    if (this.data.isPlaying) {
      backgroundAudioManager.pause()
    } else {
      backgroundAudioManager.play()
    }
    this.setData({
      isPlaying: !this.data.isPlaying
    })
  },
  // 上一首
  onPrev() {
    nowPlayingIndex--
    // 说明是第一首
    if (nowPlayingIndex < 0) {
      // 那么跳到最后一首
      nowPlayingIndex = musiclist.length - 1
      this._loadMusicDetail(musiclist[nowPlayingIndex].id)
    } else {
      this._loadMusicDetail(musiclist[nowPlayingIndex].id)
    }
  },
  // 下一首
  onNext() {
    nowPlayingIndex++
    let musicListLen = musiclist.length
    // 因为nowPlayingIndex是从0开始，加1后才会和长度匹配
    if (nowPlayingIndex === musicListLen) {
      nowPlayingIndex = 0
      this._loadMusicDetail(musiclist[nowPlayingIndex].id)
    } else {
      this._loadMusicDetail(musiclist[nowPlayingIndex].id)
    }
  },
  // 加载歌曲的回调
  _loadMusicDetail(musicId) {
    // 加载下一首之前先停止上一首
    backgroundAudioManager.stop()
    wx.showLoading({
      title: '歌曲加载中~',
    })
    let music = musiclist[nowPlayingIndex]
    wx.setNavigationBarTitle({
      title: music.name,
    })
    this.setData({
      picUrl: music.al.picUrl
    })

    wx.cloud.callFunction({
      name: 'music',
      data: {
        $url: 'musicUrl',
        musicId
      }
    }).then(res => {
      console.log(res, '歌曲信息')
      let result = res.result.data[0]
      // 底部歌曲工具栏展示的信息
      backgroundAudioManager.src = result.url
      backgroundAudioManager.title = music.name
      backgroundAudioManager.coverImgUrl = music.al.picUrl
      backgroundAudioManager.singer = music.ar[0].name
      backgroundAudioManager.epname = music.al.name
      // 设置播放状态为true
      this.setData({
        isPlaying: true
      })
      wx.hideLoading()
    }).catch(err => {
      console.log(err, 'err')
    })

    console.log(music, '???')
  }
})
```

## 4.5如何在小程序中获取某个元素的属性

- 如果在页面中则为wx.createSelectorQuery()
- 如果在组件中则为this.createSelectorQuery()

```javascript
      // wx.createSelectorQuery()
      const query = this.createSelectorQuery()
      query.select('.movable-area').boundingClientRect()
      query.select('.movable-view').boundingClientRect()
      query.exec((rect) => {
        movableAreaWidth = rect[0].width
        movableViewWidth = rect[1].width
        console.log(rect, 'rect')
      })
```

## 4.6小程序中操作进度条的事件(及获取音乐长度)

- const getBackgroundAudioManager = wx.getBackgroundAudioManager()
- 获取了获取**全局唯一**的背景音频管理器
- <https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/wx.getBackgroundAudioManager.html>官方文档
- 一般在onCanplay也就是音乐进入播放状态时触发。当你切换下一首时也会触发，获取管理器的duration，得到的是当前音乐的时长（秒）
- 对数据进行处理转化为 00:00的形式展示

```javascript
// components/progress-bar/progress-bar.js
// 把获取到的move部分宽度存储起来
let movableAreaWidth = 0
let movableViewWidth = 0
let currSec = 0
let duration = 0
// 判断当前是否正在移动
let isMoving = false
const getBackgroundAudioManager = wx.getBackgroundAudioManager()
Component({
  /**
   * 组件的属性列表
   */
  properties: {

  },

  /**
   * 组件的初始数据
   */
  data: {
    showTime: {
      currentTime: '00:00',
      totalTime: '00:00',
      // movable-view x移动的距离
      movableDis: 0,
      progress: 0, // 进度条移动距离
    }
  },
  lifetimes: {
    ready() {
      this._getMovableDis()
      this._bindBGMEvent()
    },
  },
  /**
   * 组件的方法列表
   */
  methods: {
    // 监听拖动movable-view的事件
    onChange(event) {
      // 当鼠标拖动时 source为 touch，正常播放是setData操作，source为空串
      if (event.detail.source == 'touch') {
        // 设置x的距离，但不会影响页面
        this.data.movableDis = event.detail.x
        this.data.progress = event.detail.x / (movableAreaWidth - movableViewWidth) * 100
        isMoving = true
      }
    },
    // 监听鼠标抬起的事件
    toucheEnd() {
      // 获取总时间，然后根据进度条的百分比算出当前时间
      let pencentTime = this.data.progress / 100 * getBackgroundAudioManager.duration
      // 格式化时间
      let nowTime = this._dateFormat(pencentTime)
      // 只有当鼠标抬起才真正的改变页面
      this.setData({
        movableDis: this.data.movableDis,
        progress: this.data.progress,
        ['showTime.currentTime']: `${nowTime.min}:${nowTime.sec}`
      })
      // 调用api把音乐播放进度调整到计算出的当前时间
      getBackgroundAudioManager.seek(pencentTime)
    },
    // 获取可移动区域的宽度
    _getMovableDis() {
      // wx.createSelectorQuery()
      const query = this.createSelectorQuery()
      query.select('.movable-area').boundingClientRect()
      query.select('.movable-view').boundingClientRect()
      query.exec((rect) => {
        movableAreaWidth = rect[0].width
        movableViewWidth = rect[1].width
        console.log(rect, 'rect')
      })
    },
    // 操作进度条的事件
    _bindBGMEvent() {
      //监听背景音频播放事件
      getBackgroundAudioManager.onPlay(() => {
        isMoving = false
        console.log('onPlay ')
      })
      // 监听背景音频停止事件
      getBackgroundAudioManager.onStop(() => {
        console.log('onStop ')
      })
      // 监听背景音频暂停事件
      getBackgroundAudioManager.onPause(() => {
        console.log('onPause ')
      })
      //监听音频加载中事件。当音频因为数据不足，需要停下来加载时会触发
      getBackgroundAudioManager.onWaiting(() => {
        console.log('onWaiting ')
      })
      // 监听背景音频进入可播放状态事件。 但不保证后面可以流畅播放
      getBackgroundAudioManager.onCanplay(() => {
        console.log(getBackgroundAudioManager.duration, 'onCanplay ')
        if (typeof getBackgroundAudioManager.duration !== 'undefined') {
          this._setTime()
        } else {
          setTimeout(() => {
            this._setTime()
          }, 1000)
        }
      })
      // 监听背景音频播放进度更新事件，只有小程序在前台时会回调
      getBackgroundAudioManager.onTimeUpdate(() => {
        // 只有没在移动的时候才可以设置值，不然在移动的时候会冲突造成圆点跳动
        if (!isMoving) {
          const currentTime = getBackgroundAudioManager.currentTime
          const duration = getBackgroundAudioManager.duration
          // 格式化时间
          let formatTime = this._dateFormat(currentTime)
          // 判断如果是同一秒内执行多次则取消执行，以便提高性能
          if (currentTime.toString().split('.')[0] !== currSec) {
            this.setData({
              ['showTime.currentTime']: `${formatTime.min}:${formatTime.sec}`,
              movableDis: (movableAreaWidth - movableViewWidth) * currentTime / duration,
              progress: currentTime / duration * 100

            })
            currSec = currentTime.toString().split('.')[0]
            // console.log(currentTime,'onTimeUpdate')
          }
        }

      })
      // 监听背景音频自然播放结束事件


      getBackgroundAudioManager.onEnded(() => {
        this.triggerEvent('musicEnd')
        console.log('onEnded ')
      })
      // 监听背景音频播放错误事件
      getBackgroundAudioManager.onError((res) => {
        console.err(res.errMsg)
        console.log(res.errCode, 'onError')
        wx.showToast({
          title: '错误:' + res.errCode,
        })
      })
    },
    // 获取duration(当前音频的长度)
    _setTime() {
      duration = getBackgroundAudioManager.duration
      const formatTime = this._dateFormat(duration)
      this.setData({
        ['showTime.totalTime']: `${formatTime.min}:${formatTime.sec}`
      })
      console.log(formatTime, 'settime')
    },
    // 格式化时间
    _dateFormat(time) {
      // 获取分钟
      const min = Math.floor(time / 60)
      // 获取秒
      const sec = Math.floor(time % 60)
      return {
        'min': this._parse0(min),
        'sec': this._parse0(sec)
      }
    },
    _parse0(sec) {
      return sec < 10 ? '0' + sec : sec
    }
  }
})
```

## 4.7解决在播放时拖动进度条会闪的bug

- 设置一个状态位isMoving
- 默认为false，当你触发onChange，也就是拖动movable-view时状态位变为true，代表正在拖动
- 如果状态位为true那么监听音乐进度更新的事件getBackgroundAudioManager.onTimeUpdate(()里面的内容就不应该执行。
- 当你触发了onPlay事件时，说明重新播放了视频也就是拖动结束，此时才可以触发更新事件

```javascript
  // 只有组件内部才有的参数，是声明周期，ready是页面准备好    
  lifetimes: {
    ready() {
      this._getMovableDis()
      this._bindBGMEvent()
    },
  },
      
      getBackgroundAudioManager.onPlay(() => {
        isMoving = false
        console.log('onPlay ')
      })
```

