# 1.0云开发学习

本地项目地址 D:\Study\云音乐

# 2.0云开发的优势

```
1.云函数支持本地调试，调试云端和调试前端代码是一样的，做到了全栈开发模式

2.可以快速上线

3.可以专注核心业务

4.减少前后端沟通成本

5.无需运维，节约成本

```

## 2.1云开发提供了哪些能力

```
1.云函数:在云端运行的代码。微信私有协议天然鉴权 （开发者可以很方便的获取到用户的openId，云函数相当于小程序的后端部分）
2.云数据库：一个既可以在小程序端操作又可以在云函数中操作的JSON数据库
3.云存储：在云端存储文件，可以在云端控制台可视化管理
4.云调用：基于云函数免鉴权使用小程序开放接口的能力
5.HTTP API：使用HTTP API开发者可以在已有服务器上访问云资源，实现与云开发的互通
```

## 2.2开通云开发

1.[https://mp.weixin.qq.com](https://mp.weixin.qq.com/)登录微信公众平台获取自己的appid

2.点击微信开发工具的左上角云开发按钮

3.点击后的弹窗=》创建环境 =》声明环境名称和环境ID后点击确定即可

## 2.3初始化项目

1.当创建完云环境后可以看见第一个文件夹使用 | 分割后面是对应环境的名称

2.miniprogram目录中的app.js是项目的配置文件，其中env代表当前对应的环境，具体可打开云开发控制台查看（设置=》环境设置=》右侧即可查看）

3.app.js中  traceUser: true  是否记录每个访问小程序的用户，并且以倒叙的形式显示

## 2.4配置tabbar

- 在app.json中输入list即可，之后按照需求配置
- color文本颜色 selectedColor 选中的文本颜色

```
  "tabBar": {
    "color":"#474747",
    "selectedColor":"#d43c43",
    "list": [
      {
      "pagePath": "pages/playlist/playlist",
      "text": "音乐",
      "iconPath": "images/music.png",
      "selectedIconPath": "images/music-actived.png"
    },
      {
      "pagePath": "pages/blog/blog",
      "text": "发现",
      "iconPath": "images/blog.png",
      "selectedIconPath": "images/blog-actived.png"
    },
      {
      "pagePath": "pages/blog/blog",
      "text": "我的",
      "iconPath": "images/profile.png",
      "selectedIconPath": "images/profile-actived.png"
    }
    ]
  },
```

## 2.5配置轮播图

- 注意获取变量需要用双大括号包裹才可以拿到值

- 不加就会变成循环这个字符串

- widthFix代表宽度占满，高度自适应，配合图片宽度100%可以完整显示轮播图

```vue
<swiper indicator-dots="true" autoplay="true" interval="2000" duration="1000">
  <block wx:for="{{swiperImgUrls}}" wx:key="*this">
    <swiper-item>
      <image src="{{item.url}}" mode="widthFix"></image>
    </swiper-item>
  </block>
</swiper>
```

## 2.6组件化的好处

- 高内聚：保证一个段一个单元的代码来解决一个需求
- 低耦合：组件和组件之间减少耦合性，组件相对独立，增强组件的复合型
- 单一职责
- 避免过多参数

## 2.7自定义播放列表组件

1. 注册组件，在components文件夹下新建playlistitem组件

```vue
<view class="playlist-container">
  <image src="{{playlist.picUrl}}" class="playlist-img"></image>
  <text class="playlist-playcount">{{playlist.playCount}}</text>
  <view class="playlist-name">{{playlist.name}}</view>
</view>
```

2. 接受父组件传过来的参数对象

```
  properties: {
    playlist: {
      type: Object,
      value: {}
    }
  },

```

3.写入样式

注意由于每个组件占一行的三分之一，因此设定宽度来实现这个效果而不是flex：1

父组件设置 display:flex 和 flex-wrap:wrap换行即可



右上角的耳机图标的设置：给容器设置了背景图片，不重复，位置为left和center，也就是靠左和居中

```css
.playlist-container {
  width: 220rpx;
  position: relative;
  padding-bottom: 20rpx;
}

.playlist-img {
  width: 100%;
  height: 220rpx;
  border-radius: 6rpx;
}

.playlist-playcount {
  font-size: 24rpx;
  color: #fff;
  text-shadow: 1px 0 0 rgba(0, 0, 0, 0.15);
  position: absolute;
  right: 10rpx;
  top: 4rpx;
  padding-left: 26rpx;
  background: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMiAyMCI+PGcgb3BhY2l0eT0iLjE1Ij48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGZpbGw9IiMwNDAwMDAiIGQ9Im0yMiAxNi43NzdjMCAxLjIzMy0xLjEyMSAyLjIzMy0yLjUwNiAyLjIzMy0xLjM4NCAwLTIuNTA2LTEtMi41MDYtMi4yMzN2LTIuNTUzYzAtMS4yMzQgMS4xMjItMi4yMzMgMi41MDYtMi4yMzMuMTc0IDAgLjM0My4wMTcuNTA2LjA0NnYtMS4zN2gtLjAzM2MuMDE3LS4yMi4wMzMtLjQ0MS4wMzMtLjY2NiAwLTQuNDE4LTMuNTgyLTgtOC04LTQuNDE4IDAtOCAzLjU4Mi04IDggMCAuMjI1LjAxNi40NDYuMDM0LjY2NmgtLjAzNHYxLjM3Yy4xNjMtLjAyOS4zMzMtLjA0Ni41MDUtLjA0NiAxLjM4NCAwIDIuNTA2Ljk5OSAyLjUwNiAyLjIzM3YyLjU1M2MwIDEuMjMzLTEuMTIyIDIuMjMzLTIuNTA2IDIuMjMzcy0yLjUwNS0uOTk5LTIuNTA1LTIuMjMzdi0yLjU1M2MwLS4yNTguMDU5LS41MDEuMTQ4LS43My0uMDg1LS4xNDgtLjE0OC0uMzEtLjE0OC0uNDkzdi0yLjY2N2MwLS4wMjMuMDEyLS4wNDMuMDEzLS4wNjctLjAwNC0uMDg4LS4wMTMtLjE3Ni0uMDEzLS4yNjYgMC01LjUyMyA0LjQ3Ny0xMCAxMC0xMCA1LjUyMyAwIDEwIDQuNDc3IDEwIDEwIDAgLjA5LS4wMDkuMTc4LS4wMTQuMjY2LjAwMi4wMjQuMDE0LjA0NC4wMTQuMDY3djJjMCAuMzA2LS4xNDUuNTY5LS4zNi43NTMuMjI0LjMzNC4zNi43Mi4zNiAxLjEzOHYyLjU1MiIvPjwvZz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGZpbGw9IiNmZmYiIGQ9Im0yMCAxNi43NzdjMCAxLjIzMy0xLjEyMSAyLjIzMy0yLjUwNiAyLjIzMy0xLjM4NCAwLTIuNTA2LTEtMi41MDYtMi4yMzN2LTIuNTUzYzAtMS4yMzQgMS4xMjItMi4yMzMgMi41MDYtMi4yMzMuMTc0IDAgLjM0My4wMTcuNTA2LjA0NnYtMS4zN2gtLjAzM2MuMDE3LS4yMi4wMzMtLjQ0MS4wMzMtLjY2NiAwLTQuNDE4LTMuNTgyLTgtOC04LTQuNDE4IDAtOCAzLjU4Mi04IDggMCAuMjI1LjAxNi40NDYuMDM0LjY2NmgtLjAzNHYxLjM3Yy4xNjMtLjAyOS4zMzMtLjA0Ni41MDUtLjA0NiAxLjM4NCAwIDIuNTA2Ljk5OSAyLjUwNiAyLjIzM3YyLjU1M2MwIDEuMjMzLTEuMTIyIDIuMjMzLTIuNTA2IDIuMjMzcy0yLjUwNS0uOTk5LTIuNTA1LTIuMjMzdi0yLjU1M2MwLS4yNTguMDU5LS41MDEuMTQ4LS43My0uMDg1LS4xNDgtLjE0OC0uMzEtLjE0OC0uNDkzdi0yLjY2N2MwLS4wMjMuMDEyLS4wNDMuMDEzLS4wNjctLjAwNC0uMDg4LS4wMTMtLjE3Ni0uMDEzLS4yNjYgMC01LjUyMyA0LjQ3Ny0xMCAxMC0xMCA1LjUyMyAwIDEwIDQuNDc3IDEwIDEwIDAgLjA5LS4wMDkuMTc4LS4wMTQuMjY2LjAwMi4wMjQuMDE0LjA0NC4wMTQuMDY3djJjMCAuMzA2LS4xNDUuNTY5LS4zNi43NTMuMjI0LjMzNC4zNi43Mi4zNiAxLjEzOHYyLjU1MiIvPjwvc3ZnPg==) no-repeat;
  background-position: left;
  background-size: 26rpx;
}

.playlist-name {
  font-size: 26rpx;
  line-height: 1.2;
  padding: 2px 0 0 6px;
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 2;
  overflow: hidden;
  text-overflow: ellipsis;
}

```

## 2.8转换组件上的播放数量

定义一个方法来转换

- 首先把小数点后的数字去掉
- 如果小于6位则不操作
- 如果大于等于6小于等于8即在一亿以下，十万以上则把万以下的数字切出来例如15422切出5422，切的数量根据传的point决定
- 返回传入数字除以10000并取整，可得万的数量，拼接上刚才切出的数字则可得 xx.xx万

```javascript
    // 根据传入的数值把数字转为带单位
    _tranNumber(num,point=2) {
      // 获取Num
      let newNum = num.toString().split(".")[0]
      if (newNum.length < 6) {
        return newNum
      } else if (newNum.length >= 6 && newNum.length <= 8) {
        let decimal = newNum.substring(newNum.length - 4, newNum.length - 4 + point)
        console.log(decimal,'decimal')
        return (parseFloat(parseInt(num / 10000) + '.' + decimal)) + '万'
      }
      else if (newNum.length > 8) {
        let decimal = newNum.substring(newNum.length - 8, newNum.length-8+point)
        return parseFloat(parseInt(num/100000000)+ '.' + decimal) + '亿'
      }
    }
```

observers是组件内部的属性，可以监听值的改变，因此监听传入的数量，并转化为可读格式后赋值给data内部的变量。注意不能在这里直接修改自己，不然会无限变化并监听变化造成死循环

```
  observers: {
    ["playlist.playCount"](val){
      console.log(val,'val')
      console.log(this._tranNumber(val,2),'@@@')
      // return this._tranNumber(val, 3)
      this.setData({
        _count: this._tranNumber(val, 2)
      })
    }
  },
```

# 3.0开发中的常见问题

## 3.1 wx:for循环

1. wx:for对应的数组/对象需要用 {{}} 双大括号包裹才可
2. wx:key 如果循环的数组是静态的，可以忽略，如果是动态的数组或者要对数组进行操作，则需要对应数组中的一个独一无二的属性，例如id



## 3.2Promise

1. promise.all 代表所有的请求都成功才会成功 ,但是不会阻止失败之后的任务的执行

   - 当文件上传的时候推荐使用，当所有的文件都上传成功才会执行回调

   ```
   Promise.all([promise请求,promise请求]).then(res=> {  console.log(res)  })
   ```


2. promise.race  代表有一个请求完成后就成功

   - 可以验证超时，把请求和一个定时器放在一起执行，如果定时器先执行说明请求超时（更慢）

   ```
   Promise.race([promise请求,promise请求]).then(res=> {  console.log(res)  })
   当其中一个请求完成就会
   ```


## 3.3云函数初体验

1. 新建一个云函数，推荐直接右键创建

2. ```
   安装依赖
   npm i request --save
   npm i request-promise --save
   ```

   调用接口发送请求

   - 注意需要先cloud.init()初始化
   - const db = cloud.database() 导入云数据库
   - 通过request-promise发送请求获取数据 ，前面要加上await
   - 获取到数据后需要JSON.parse（res）把返回的数据转换为对象，有时返回的是JSON字符串，因此用于保险
   - 获取到数据后通过数据库的add方法插入到云数据库中，注意方法前要加上 awiat  ( await db.collection("playlist").add )
   - 要想插入数据需要在add内部对象定义一个data才可插入数据，单独写add（{}）无效
   - 完成后上传到云端并在云端测试

   ```vue
   // 云函数入口文件
   const cloud = require('wx-server-sdk')
   
   cloud.init()
   
   const db = cloud.database()
   
   const rp = require("request-promise")
   
   const URL = 'http://musicapi.xiecheng.live/personalized'
   
   // 云函数入口函数
   exports.main = async (event, context) => {
     const wxContext = cloud.getWXContext()
     let playlist = await rp(URL).then(res=> {
       return JSON.parse(res).result
     })
     console.log(playlist)
     for (let i = 0; i < playlist.length;i++) {
       await db.collection("playlist").add({
         data: {
           ...playlist[i],
           createTime: db.serverDate()
         }
       }).then(res=>{
         console.log('插入成功')
       }).catch(err=> {
         console.log(err,'err')
       })
     }
     
   
     return {
       event,
       openid: wxContext.OPENID,
       appid: wxContext.APPID,
       unionid: wxContext.UNIONID,
     }
   }
   ```

## 3.4新增去重操作

- 注意  db.collection("playlist").get()  获取到的数据需要再 .data才能获取到要操作的数组！

```vue
// 云函数入口文件
const cloud = require('wx-server-sdk')

cloud.init()

const db = cloud.database()

const rp = require("request-promise")

const URL = 'http://musicapi.xiecheng.live/personalized'

const getDb = db.collection("playlist")

// 云函数入口函数
exports.main = async(event, context) => {
  // 获取数据库中的已有数据
  let list = await getDb.get()
  console.log(list, '输出list')
  // 定义一个数组用于插入数据
  let newArr = []
  // 接口获取的新数据
  let playlist = await rp(URL).then(res => {
    return JSON.parse(res).result
  })
  for (let i = 0; i < playlist.length; i++) {
    let flag = true
    for (let j = 0; j < list.data.length; j++) {
      if (playlist[i].id === list.data[i].id) {
        flag = false
      }
    }
    if (flag) {
      newArr.push(playlist[i])
    }
  }

  console.log(newArr, '输出newArr')
  for (let i = 0; i < newArr.length; i++) {
    await getDb.add({
      data: {
        ...newArr[i],
        createTime: db.serverDate()
      }
    }).then(res => {
      console.log('插入成功')
    }).catch(err => {
      console.log(err, 'err')
    })
  }


  return
}
```

## 3.5分段取出数据库的所有数据

- 云数据库有限制，一次只能取出100条数据

- 因此获取总数，然后分次数拿到每次返回的promise对象

- 通过promise.all 和 reduce方法拼接返回的参数

  ```vue
    // 获取数据库中的已有数据
    let countResult = await getDb.count()
    // 拿到数据总数
    let total = countResult.total
    console.log(total,'total')
    // 获取的次数
    let batchTimes = Math.ceil(total/10)
    let tasks = []
    for (let i=0;i<batchTimes;i++) {
      // 这里不加await因为promise.all需要 promise对象
      let promise = getDb.skip(i*MAX_LIMIT).limit(MAX_LIMIT).get()
      tasks.push(promise)
    }
    let list = {
      data: []
    }
    console.log(tasks, '输出tasks')
    // 说明数据库不为空
    if (tasks.length > 0) {
      // await获取Promise.all的结果
      list = (await Promise.all(tasks)).reduce((acc,cur)=> {
        return {
          data: acc.data.concat(cur.data)
        }
      })
    }
    console.log(list,'输出list')
  ```

  ### 3.6触发器的使用

  - 触发器可以设置在某个时间点调用云函数

  - 在云函数的目录下新建conifg.json文件，写入下列代码

    ```
    {
      "triggers": [
        {
          "name": "myTrigger",
          "type": "timer",
          "config": "0 0 10,14,16,23 * * * *"
        }
      ]
    }
    ```

    完成后必须上传触发器才可生效

    config对应的是时间的格式 具体参考

    <https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/functions/triggers.html>

    本次含义为 每天的10点2点4点半夜11点触发一次

## 3.7获取音乐的云函数

- 调用定义的音乐云函数

- event就是你传入的data对象

- ```
  // 云函数入口文件
  const cloud = require('wx-server-sdk')
  
  cloud.init()
  
  // 云函数入口函数
  exports.main = async(event, context) => {
    // 获取音乐数据
    return await cloud.database().collection('playlist').skip(event.start).limit(event.count).orderBy('createTime', 'desc').get().then(res => {
      return res
    })
  
  }
  ```

  在页面的js中应用

```javascript
  _getPlayList() {
    wx.showLoading({
      title: '玩命加载中~',
    })
    // 获取音乐列表,start动态根据数组的长度变化
    wx.cloud.callFunction({
      name: 'music',
      data: {
        start: this.data.playlist.length,
        count: MAX_LIMIT
      }
    }).then(res => {
      console.log(res, '输出结果')
      this.setData({
        playlist: this.data.playlist.concat(res.result.data) 
      })
      // 请求完成隐藏下拉小点
      wx.stopPullDownRefresh()
      wx.hideLoading()
    }).catch(err => {
      wx.hideLoading()
      console.log(err, 'err')
    })
  },
```

## 3.8使用tcb-router管理云函数

- 为了解决云函数上限50个，因此使用tcb-router来管理相同类型的云函数

- 安装tab-router   npm i tcb-router --save

- 新建tabRouter云函数

- const app = new TcbRouter({event}) 必须传入event不然返回值为空

- app.router 定义路由

- 必须返回   return app.serve()

- 调用方法

  ```javascript
      wx.cloud.callFunction({ 
        name: 'tcbRouter',
        data: {
        // 路由名称
          $url: 'music'
        },
      }).then(res=> { 
        console.log(res,'res')
      })
  ```



  ```javascript
  // 云函数入口文件
  const cloud = require('wx-server-sdk')
  const TcbRouter = require('tcb-router')
  
  cloud.init()
  
  // 云函数入口函数
  exports.main = async(event, context) => {
    // 传入event参数，这样tab就会自动处理参数的转发
    const app = new TcbRouter({event})
  
    app.use(async(ctx, next) => {
      ctx.data = {}
      ctx.data.openId = event.userInfo.openId
      ctx.data.event = event
      await next()
    })
  
    app.router('music', async(ctx, next) => {
      ctx.data.musicName = '义勇军进行曲'
      await next()
    }, async(ctx, next) => {
      ctx.data.musicType = '国歌'
      ctx.body = {
          data: ctx.data
        }
    })
  
    app.router('movie', async(ctx, next) => {
      ctx.data.movieName = "千与千寻"
      await next()
    }, async(ctx, next) => {
      ctx.data.movieType = "日漫"
      ctx.body = {
        data: ctx.data
      }
    })
  
    return app.serve()
  }
  ```


## 3.9tcb-router的简单使用

- 云函数使用tcb-router

- 安装导入 tcb-router 后必须初始化并传入事件对象

- 最后要 返回 app.serve ()

  ```javascript
  
  // 云函数入口函数
  exports.main = async(event, context) => {
    const app = new TcbRouter({
      event
    })
    // 全局中间件
    app.use(async(ctx, next) => {
      await next()
    })
    app.router('music', async(ctx, next) => {
      // 获取音乐数据
      ctx.body = await cloud.database().collection('playlist').skip(event.start).limit(event.count).orderBy('createTime', 'desc').get().then(res => {
        return res
      })
      await next()
    })
  
    // 获取音乐数据
    // return await cloud.database().collection('playlist').skip(event.start).limit(event.count).orderBy('createTime', 'desc').get().then(res => {
    //   return res
    // })
    return app.serve()
  }
  ```

  使用该云函数

  - 如果使用了 tcb-router 的路由

  - 则需要传入 $url 对应路由的名称才可以调用

  ```javascript
      wx.cloud.callFunction({
        name: 'music',
        data: {
          $url:'music',
          start: this.data.playlist.length,
          count: MAX_LIMIT
        }
      }).then(res => {
        console.log(res, '输出结果')
        this.setData({
          playlist: this.data.playlist.concat(res.result.data) 
        })
        // 请求完成隐藏下拉小点
        wx.stopPullDownRefresh()
        wx.hideLoading()
      }).catch(err => {
        wx.hideLoading()
        console.log(err, 'err')
      })
  ```




## 3.10 小程序拓展

- 点击事件时对象的 target 和 currenttarget的区别
- target是你点击的元素，currenttarget是你绑定事件的元素

# 4.0播放页面制作

## 4.1进入歌曲列表时把数据存入本地

- 进入时会带入playlistId，也就是这个歌曲目录的id，根据云函数获取到对应的歌曲目录，并存入本地

```javascript
  _getMusicList() {
    wx.cloud.callFunction({
      name: 'music',
      data: {
        playlistId: this.data.playlistId,
        $url: 'musiclist'
      }
    }).then(res => {
      const pl = res.result.playlist
      this.setData({
        musiclist: pl.tracks,
        listInfo: {
          coverImgUrl: pl.coverImgUrl,
          name: pl.name
        }
      })
      this._setMusicList()
      wx.hideLoading()
      console.log(res, '输出结果')
    }).catch(err => {
      wx.hideLoading()
      console.log(err, '错误输出')
    })
  },
  _setMusicList() {
    // 同步的把歌曲列表数据存入本地
    wx.setStorageSync('musiclist', this.data.musiclist)
  },
```

## 4.2点击歌曲列表中的某一项高亮并进入详情页

- 定义一个列表组件，把歌曲列表的数据传入，循环渲染歌曲列表。
- 顶部高斯模糊背景加一张图片
- 相当于遮罩层在最下方，容器在遮罩层上方，设置了背景图片但是是模糊的，并且有透明度，因此可看到遮罩层的背景色
- 之后吧封面图片定位在上方即可

```html
// wxml
<view class="musiclist-container" style="background:url({{listInfo.coverImgUrl}}) no-repeat"></view>
<view class="detail-mask"></view>

// wxss
.musiclist-container {
  height: 320rpx;
  filter: blur(40rpx);
  opacity: 0.4;
  
}

/*遮罩层*/
.detail-mask {
  position: absolute;
  left: 0;
  top: 0;
  z-index: -1;
  height: 320rpx;
  width: 100%;
  background-color: #333;
}

```

## 4.3绘制歌曲详情页

- wxss
- 定义了一个遮罩层在最底部。设置一个容器背景图片为当前歌曲封面并设置高斯模糊。这两个容器都是覆盖整个页面的
- 上方指针动画是一张图片使用伪元素定位到上方的。当点击播放去除一个play 类。可以实现动画

```html
<view class="player-container" style="background:url({{picUrl}}) center/cover no-repeat"></view>
<view class="player-mask"></view>

<view class="player-info">
  <view class="player-disc {{isPlaying ? 'play' : ''}}">
    <image class="playerimg rotation {{isPlaying? '' : 'pauseRotate'}}" src="{{picUrl}}"></image>
  </view>
</view>
<view class="control">
  <text class="iconfont icon-shangyishoushangyige" bindtap="onPrev"></text>
  <text class="iconfont {{isPlaying ? 'icon-zanting1' : 'icon-bofang1'}}" bind:tap="togglePlaying"></text>
  <text class="iconfont icon-xiayigexiayishou" bindtap="onNext"></text>
</view>
```

```css
/* pages/player/player.wxss */

.player-container {
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  background: center;
  filter: blur(40rpx);
  opacity: 0.4;
  z-index: -1;
}

.player-mask {
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  right: 0;
  z-index: -2;
  background-color: #222;
}

.player-info {
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  text-align: center;
}

.player-disc {
  width: 592rpx;
  height: 592rpx;
  background: url(https://s3.music.126.net/mobile-new/img/disc.png?d3bdd1080a72129346aa0b4b4964b75f=) no-repeat center/contain;
  position: absolute;
  left: 50%;
  transform: translate(-50%, 140rpx);
  /* top: 50%; */
}

.player-disc::after {
  content: '';
  position: absolute;
  width: 192rpx;
  height: 192rpx;
  left: 266rpx;
  top: -144rpx;
  background: url(https://s3.music.126.net/m/s/img/needle.png?702cf6d95f29e2e594f53a3caab50e12) no-repeat center/contain;
  transform: rotate(-15deg);
  transform-origin: 24rpx 10rpx;
  transition: all 0.5s ease;
} 

.play.player-disc::after {
  transform: rotate(5deg);
}

.playerimg {
  width: 368rpx;
  height: 368rpx;
  border-radius: 50%;
  position: absolute;
  left: 50%;
  top: 50%;
  margin-top: -184rpx;
  margin-left: -184rpx;
  /* transform: translate(-50%, -50%); */
  /* transform: translate(30%,30%); */
}

/* 播放控件部分 */

.control {
  position: absolute;
  left: 50%;
  bottom: 8%;
  transform: translate(-50%);
  display: flex;
  align-items: center;
}

.control .iconfont {
  color: #e2e2e2;
}

.icon-shangyishoushangyige, .icon-xiayigexiayishou {
  font-size: 80rpx;
}

.icon-bofang1, .icon-zanting1 {
  font-size: 100rpx;
  margin: 0 28rpx;
}

.rotation {
    -moz-animation: rotation infinite linear 12s;
    -o-animation: rotation infinite linear 12s;
    -webkit-animation: rotation infinite linear 12s;
    animation: rotation infinite linear 12s ;
}

.pauseRotate {
  animation-play-state: paused;
}

@keyframes rotation {
  0% {
    transform: rotate(0deg)
  }
  100% {
    transform: rotate(360deg)
  }
}
```

## 4.4调用小程序音乐管理的api

- wx.getBackgroundAudioManager() 是小程序获取**全局唯一**的背景音频管理器
- <https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/wx.getBackgroundAudioManager.html>官方文档

```javascript
// pages/player/player.js
// 当数据不用于展示时最好不定义在data中
let musiclist = []
// 当前正在播放歌曲的index
let nowPlayingIndex = 0
// 获取全局唯一的背景音频管理器
const backgroundAudioManager = wx.getBackgroundAudioManager()
Page({

  /**
   * 页面的初始数据
   */
  data: {
    picUrl: '',
    isPlaying: false
  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function(options) {
    console.log(options, '@@')
    nowPlayingIndex = options.index
    // 获取本地存储的数据
    musiclist = wx.getStorageSync('musiclist')
    this._loadMusicDetail(options.musicId)
  },
  // 切换播放与暂停状态
  togglePlaying() {
    console.log(this.data.isPlaying, '点击')
    if (this.data.isPlaying) {
      backgroundAudioManager.pause()
    } else {
      backgroundAudioManager.play()
    }
    this.setData({
      isPlaying: !this.data.isPlaying
    })
  },
  // 上一首
  onPrev() {
    nowPlayingIndex--
    // 说明是第一首
    if (nowPlayingIndex < 0) {
      // 那么跳到最后一首
      nowPlayingIndex = musiclist.length - 1
      this._loadMusicDetail(musiclist[nowPlayingIndex].id)
    } else {
      this._loadMusicDetail(musiclist[nowPlayingIndex].id)
    }
  },
  // 下一首
  onNext() {
    nowPlayingIndex++
    let musicListLen = musiclist.length
    // 因为nowPlayingIndex是从0开始，加1后才会和长度匹配
    if (nowPlayingIndex === musicListLen) {
      nowPlayingIndex = 0
      this._loadMusicDetail(musiclist[nowPlayingIndex].id)
    } else {
      this._loadMusicDetail(musiclist[nowPlayingIndex].id)
    }
  },
  // 加载歌曲的回调
  _loadMusicDetail(musicId) {
    // 加载下一首之前先停止上一首
    backgroundAudioManager.stop()
    wx.showLoading({
      title: '歌曲加载中~',
    })
    let music = musiclist[nowPlayingIndex]
    wx.setNavigationBarTitle({
      title: music.name,
    })
    this.setData({
      picUrl: music.al.picUrl
    })

    wx.cloud.callFunction({
      name: 'music',
      data: {
        $url: 'musicUrl',
        musicId
      }
    }).then(res => {
      console.log(res, '歌曲信息')
      let result = res.result.data[0]
      // 底部歌曲工具栏展示的信息
      backgroundAudioManager.src = result.url
      backgroundAudioManager.title = music.name
      backgroundAudioManager.coverImgUrl = music.al.picUrl
      backgroundAudioManager.singer = music.ar[0].name
      backgroundAudioManager.epname = music.al.name
      // 设置播放状态为true
      this.setData({
        isPlaying: true
      })
      wx.hideLoading()
    }).catch(err => {
      console.log(err, 'err')
    })

    console.log(music, '???')
  }
})
```

## 4.5如何在小程序中获取某个元素的属性

- 如果在页面中则为wx.createSelectorQuery()
- 如果在组件中则为this.createSelectorQuery()

```javascript
      // wx.createSelectorQuery()
      const query = this.createSelectorQuery()
      query.select('.movable-area').boundingClientRect()
      query.select('.movable-view').boundingClientRect()
      query.exec((rect) => {
        movableAreaWidth = rect[0].width
        movableViewWidth = rect[1].width
        console.log(rect, 'rect')
      })
```

## 4.6小程序中操作进度条的事件(及获取音乐长度)

- const getBackgroundAudioManager = wx.getBackgroundAudioManager()
- 获取了获取**全局唯一**的背景音频管理器
- <https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/wx.getBackgroundAudioManager.html>官方文档
- 一般在onCanplay也就是音乐进入播放状态时触发。当你切换下一首时也会触发，获取管理器的duration，得到的是当前音乐的时长（秒）
- 对数据进行处理转化为 00:00的形式展示

```javascript
// components/progress-bar/progress-bar.js
// 把获取到的move部分宽度存储起来
let movableAreaWidth = 0
let movableViewWidth = 0
let currSec = 0
let duration = 0
// 判断当前是否正在移动
let isMoving = false
const getBackgroundAudioManager = wx.getBackgroundAudioManager()
Component({
  /**
   * 组件的属性列表
   */
  properties: {

  },

  /**
   * 组件的初始数据
   */
  data: {
    showTime: {
      currentTime: '00:00',
      totalTime: '00:00',
      // movable-view x移动的距离
      movableDis: 0,
      progress: 0, // 进度条移动距离
    }
  },
  lifetimes: {
    ready() {
      this._getMovableDis()
      this._bindBGMEvent()
    },
  },
  /**
   * 组件的方法列表
   */
  methods: {
    // 监听拖动movable-view的事件
    onChange(event) {
      // 当鼠标拖动时 source为 touch，正常播放是setData操作，source为空串
      if (event.detail.source == 'touch') {
        // 设置x的距离，但不会影响页面
        this.data.movableDis = event.detail.x
        this.data.progress = event.detail.x / (movableAreaWidth - movableViewWidth) * 100
        isMoving = true
      }
    },
    // 监听鼠标抬起的事件
    toucheEnd() {
      // 获取总时间，然后根据进度条的百分比算出当前时间
      let pencentTime = this.data.progress / 100 * getBackgroundAudioManager.duration
      // 格式化时间
      let nowTime = this._dateFormat(pencentTime)
      // 只有当鼠标抬起才真正的改变页面
      this.setData({
        movableDis: this.data.movableDis,
        progress: this.data.progress,
        ['showTime.currentTime']: `${nowTime.min}:${nowTime.sec}`
      })
      // 调用api把音乐播放进度调整到计算出的当前时间
      getBackgroundAudioManager.seek(pencentTime)
    },
    // 获取可移动区域的宽度
    _getMovableDis() {
      // wx.createSelectorQuery()
      const query = this.createSelectorQuery()
      query.select('.movable-area').boundingClientRect()
      query.select('.movable-view').boundingClientRect()
      query.exec((rect) => {
        movableAreaWidth = rect[0].width
        movableViewWidth = rect[1].width
        console.log(rect, 'rect')
      })
    },
    // 操作进度条的事件
    _bindBGMEvent() {
      //监听背景音频播放事件
      getBackgroundAudioManager.onPlay(() => {
        isMoving = false
        console.log('onPlay ')
      })
      // 监听背景音频停止事件
      getBackgroundAudioManager.onStop(() => {
        console.log('onStop ')
      })
      // 监听背景音频暂停事件
      getBackgroundAudioManager.onPause(() => {
        console.log('onPause ')
      })
      //监听音频加载中事件。当音频因为数据不足，需要停下来加载时会触发
      getBackgroundAudioManager.onWaiting(() => {
        console.log('onWaiting ')
      })
      // 监听背景音频进入可播放状态事件。 但不保证后面可以流畅播放
      getBackgroundAudioManager.onCanplay(() => {
        console.log(getBackgroundAudioManager.duration, 'onCanplay ')
        if (typeof getBackgroundAudioManager.duration !== 'undefined') {
          this._setTime()
        } else {
          setTimeout(() => {
            this._setTime()
          }, 1000)
        }
      })
      // 监听背景音频播放进度更新事件，只有小程序在前台时会回调
      getBackgroundAudioManager.onTimeUpdate(() => {
        // 只有没在移动的时候才可以设置值，不然在移动的时候会冲突造成圆点跳动
        if (!isMoving) {
          const currentTime = getBackgroundAudioManager.currentTime
          const duration = getBackgroundAudioManager.duration
          // 格式化时间
          let formatTime = this._dateFormat(currentTime)
          // 判断如果是同一秒内执行多次则取消执行，以便提高性能
          if (currentTime.toString().split('.')[0] !== currSec) {
            this.setData({
              ['showTime.currentTime']: `${formatTime.min}:${formatTime.sec}`,
              movableDis: (movableAreaWidth - movableViewWidth) * currentTime / duration,
              progress: currentTime / duration * 100

            })
            currSec = currentTime.toString().split('.')[0]
            // console.log(currentTime,'onTimeUpdate')
          }
        }

      })
      // 监听背景音频自然播放结束事件


      getBackgroundAudioManager.onEnded(() => {
        this.triggerEvent('musicEnd')
        console.log('onEnded ')
      })
      // 监听背景音频播放错误事件
      getBackgroundAudioManager.onError((res) => {
        console.err(res.errMsg)
        console.log(res.errCode, 'onError')
        wx.showToast({
          title: '错误:' + res.errCode,
        })
      })
    },
    // 获取duration(当前音频的长度)
    _setTime() {
      duration = getBackgroundAudioManager.duration
      const formatTime = this._dateFormat(duration)
      this.setData({
        ['showTime.totalTime']: `${formatTime.min}:${formatTime.sec}`
      })
      console.log(formatTime, 'settime')
    },
    // 格式化时间
    _dateFormat(time) {
      // 获取分钟
      const min = Math.floor(time / 60)
      // 获取秒
      const sec = Math.floor(time % 60)
      return {
        'min': this._parse0(min),
        'sec': this._parse0(sec)
      }
    },
    _parse0(sec) {
      return sec < 10 ? '0' + sec : sec
    }
  }
})
```

## 4.7解决在播放时拖动进度条会闪的bug

- 设置一个状态位isMoving
- 默认为false，当你触发onChange，也就是拖动movable-view时状态位变为true，代表正在拖动
- 如果状态位为true那么监听音乐进度更新的事件getBackgroundAudioManager.onTimeUpdate(()里面的内容就不应该执行。
- 当你触发了onPlay事件时，说明重新播放了视频也就是拖动结束，此时才可以触发更新事件

```javascript
  // 只有组件内部才有的参数，是声明周期，ready是页面准备好    
  lifetimes: {
    ready() {
      this._getMovableDis()
      this._bindBGMEvent()
    },
  },
      
      getBackgroundAudioManager.onPlay(() => {
        isMoving = false
        console.log('onPlay ')
      })
```

## 4.8歌词组件数据的解析

- 使用组件内部的observers监听获取到歌词数据并触发下面的函数

- 运用正则匹配出时间部分，并切出对应的时分秒

- 剩下的部分为歌词，都取出后遍历放入一个数组中用于展示

  ```javascript
      _parseLyric(sLyric) {
        // 通过换行符分割为数组
        let line = sLyric.split("\n")
        // 定义一个数组存储格式化后的歌曲信息
        let _lrcList = []
        line.forEach((item) => {
          // 获取前面的时间部分
          let time = item.match(/\[(\d{2,}):(\d{2})(?:\.(\d{2,3}))]/g)
          if (time !== null) {
            // 获取时间后面的歌词部分
            let lrc = item.split(time)[1]
            // 获取小时，分钟，秒
            let timeReg = time[0].match(/(\d{2}):(\d{2})(?:\.(\d{2,3})?)/)
            let time2Seconds = parseInt(timeReg[1]) * 60 + parseInt(timeReg[2]) * 1 +
              parseInt(timeReg[3]) / 1000
            _lrcList.push({
              lrc,
              time: time2Seconds
            })
            // console.log(_lrcList, 'lrc')
          }
          console.log(time, 'time')
        })
        this.setData({
          lrcList: _lrcList
        })
        // console.log(line,'line')
      }
  ```


## 4.8根据播放进度高亮对应歌词

- 首先从进度条组件获取当前播放到的事件

- 内部把这个时间传出去

  ```javascript
              this.triggerEvent("timeUpdate", {
                currentTime
              })
  ```

- 外部也就是播放详情页接收到后再传给子组件  歌词组件

- 直接使用小程序的api   selectComponent 获取歌词组件并调用内部的方法upDate

  ```
    timeUpdate(event) {
      // console.log(event,'??')
      // 通过selectComponent获取子组件实例，调用内部方法传入数据
      this.selectComponent('.lyric').upDate(event.detail.currentTime)
    },
  ```

- 歌词组件内部定义update方法

- 接受了这个参数，并与事件列表一一对应，如果当前在播放第5s，遍历数组，如果某一项歌词对应的事件比这个时间大，说明正好对应这个歌词的上一个歌词，那么循环终止，把上一个歌词的对应序号传给页面，页面遍历找到对应序号的歌词并高亮

  ```javascript
      upDate(currentTime) {
        console.log(currentTime, 'update')
        let lrclist = this.data.lrcList
        // 如果没有歌词
        if (lrclist.length < 1) return
        for (let i = 0; i < lrclist.length; i++) {
          if (currentTime <= lrclist[i].time) {
            this.setData({
              currentLyric: i - 1,
              scrollTop: this.data.currentItemHeight * i
            })
            // 找到了则终止循环
            break
          }
        }
      }
  ```


## 4.9根据播放进度滚动歌词

- 在组件内的生命周期中，实用小程序的api获取设备信息。计算出对应这个设备的rpx比例，乘上每一项歌词的高度。可得在这个设备中，每一项歌词的高度

  ```
    lifetimes: {
      ready() {
        let Info  =wx.getSystemInfoSync()
        console.log(Info,'info')
        // 获取当前屏幕对应的rpx比例 (屏幕宽度/750)
        // 之后用这个比例乘上之前定义的rpx高度，可得对应的每一行歌词的px高度
        // 方便判断时间时改变scrollTop (scrollTop只接受px单位)
        let currentHeight = Info.windowWidth / 750 * 64
        this.setData({
          currentItemHeight: currentHeight
        })
      }
    },
  ```

- 之后在高亮歌词的同时，滚动scroll-view .  这依赖了他的属性scrollTop

  ```
      // 也是判断当前播放时间与歌词列表时间是否对应，以便高亮当前歌词的方法
      upDate(currentTime) {
        console.log(currentTime, 'update')
        let lrclist = this.data.lrcList
        // 如果没有歌词
        if (lrclist.length < 1) return
        for (let i = 0; i < lrclist.length; i++) {
          if (currentTime <= lrclist[i].time) {
            this.setData({
              currentLyric: i - 1,
              scrollTop: this.data.currentItemHeight * i
            })
            // 找到了则终止循环
            break
          }
        }
      }
  ```


## 4.10当当前播放部分对应没有歌词时的处理

```
      // 如果当前播放的部分没有对应歌词，那么会移动到最底部并不会高亮
      // 如果最后一项有时间，不为空
      if (this.data.setFlag && lrclist[lrclist.length - 1] && currentTime > lrclist[lrclist.length - 1].time) {
        console.log('进入1')
        this.setData({
          currentLyric: -1,
          scrollTop: this.data.currentItemHeight * lrclist.length,
          setFlag: false
        })
      }
```

## 4.11musiclist组件根据播放的歌曲动态高亮

- 在app.js中设定全局变量
- 当player.js中的加载歌曲回调触发时设置 音乐id，当musiclist音乐列表组件被显示的时候，在其组件-页面生命周期中获取当前全局的音乐id并赋值给内部
- 注意要使用全局的变量或者方法
- 必须先 const App = getApp ()
- 之后就可以 app.全局方法名

```
    this.globalData = {
      // 设定全局的musicId,也就是正在播放的id
      playingMusicId: -1
    }
  },
  // 设定全局id的方法
  setPlayMusicId(musicId) {
    this.globalData.playingMusicId = musicId
  },
  // 获取全局id的方法
  getPlayMusicId() {
    return this.globalData.playingMusicId
  }
```

## 4.12点击同一首歌曲不会重新播放

- 获取全局的musicId判断与当前播放音乐的 id是否相同

- 如果相同那么不初始化音乐播放

  ```javascript
      wx.cloud.callFunction({
        name: 'music',
        data: {
          $url: 'musicUrl',
          musicId
        }
      }).then(res => {
        console.log(res, '歌曲信息')
        let result = res.result.data[0]
        // 当前歌曲是vip专属，无法播放
        if (result.url == null) {
          wx.showToast({
            title: '无权限播放',
          })
          return
        }
        // 底部歌曲工具栏展示的信息
        if (!this.data.isSame) {
          // 设定这些信息会重新加载
          backgroundAudioManager.src = result.url
          backgroundAudioManager.title = music.name
          backgroundAudioManager.coverImgUrl = music.al.picUrl
          backgroundAudioManager.singer = music.ar[0].name
          backgroundAudioManager.epname = music.al.name
        }
        // 设置播放状态为true
          this.setData({
            isPlaying: true
          })
        // 获取当前歌曲的歌词
        wx.cloud.callFunction({
          name: 'music',
          data: {
            $url: 'lyric',
            musicId
          }
        }).then(res => {
          // let lyr = JSON.parse(res.result).lrc.lyric
          let lyr = JSON.parse(res.result).lrc
          // console.log(lyr,'要给的')
          if (lyr.lyric) {
            // 获取歌词并赋值
            this.setData({
              lyric: lyr.lyric
            })
          } else {
            this.setData({
              lyric: '暂无歌词'
            })
          }
        })
        wx.hideLoading()
      }).catch(err => {
        console.log(err, 'err')
      })
  ```

  ## 4.13点击底部控件同时操作播放按钮

  - progress.js 中监听控件的暂停和开始事件。调用父组件的方法。动态更改播放状态

    ```
          getBackgroundAudioManager.onPlay(() => {
            this.triggerEvent('onPlay')
            isMoving = false
            console.log('onPlay ')
          })
          // 监听背景音频停止事件
          getBackgroundAudioManager.onStop(() => {
            console.log('onStop ')
          })
          // 监听背景音频暂停事件
          getBackgroundAudioManager.onPause(() => {
            console.log('onPause ')
            this.triggerEvent('onPause')
          })
    ```

  - 父组件player.js

    ```
      onPlay() {
        this.setData({
          isPlaying: true
        })
      },
      onPause() {
        this.setData({
          isPlaying: false
        })
      },
    ```

# 5.0发现页面制作

## 5.1发现页面头部布局

- blog.wxml定义布局

  ```html
  <view class="container">
    <!-- 头部部分 -->
    <view class="header">
      <view class="publish-container">
        <i class="iconfont icon-fabu" />
      </view>
      <view class="search-container">
        <x-search iconfont="iconfont" icon-sousuo="icon-sousuo" />
      </view>
    </view>
  </view>
  ```

- 定义blog.wxss样式

  ```css
  /* pages/blog/blog.wxss */
  .container {}
  /* 头部部分 */
  .header {
    display: flex;
    height: 100rpx;
    align-items: center;
    background-color: #fff;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    border:1px solid red;
    z-index: 99;
    width: 100%;
    padding: 0 20rpx;
    box-sizing: border-box;
  }
  
  .search-container {
    flex: 1;
    /* border: 1px solid blue; */
  }
  
  .publish-container {
    width: 68rpx;
    height: 68rpx;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  .publish-container > .icon-fabu {
    font-size: 48rpx;
  }
  ```


## 5.2搜索框组件布局

- search 组件

  ```
  <view class="container">
    <i class="iconfont icon-sousuo search-icon" />
    <input class="bar input-plc" placeholder="{{placeholder}}"></input>
    <button class="search" size="mini">搜索</button>
  </view>
  ```

- search 组件样式

  ```css
  /* components/search/search.wxss */
  
  .container {
    width: 100%;
    position: relative;
    /* margin-left: 20rpx; */
    display: flex;
    align-items: center;
  }
  
  .search-icon {
  width: 55rpx;
  height: 55rpx;
  position: absolute;
  left: 22rpx;
  top: 19rpx;
  
  }
  
  .bar {
    flex: 1;
    /* width: 100%; */
    /* flex-grow: 1; */
    background-color: #f5f5f5;
    height: 68rpx;
    border-radius: 20rpx;
    padding-left: 68rpx;
  }
  
  .search {
    background-color: #d43c33;
    color: #fff;
    font-size: 24rpx;
    margin-left: 20rpx;
  }
  
  .container > .search {
    padding: 0 1.5em;
    border-radius: 16rpx;
  }
  
  .input-plc {
    color: #999;
  }
  
  ```

- 使用外部样式

  ```
  因为组建内部无法获取全局的app.css样式
  因此使用组建内部的
    externalClasses:[
      "iconfont",
      "icon-sousuo"
    ],
  方法来获取样式
  父组件      <x-search iconfont="iconfont" icon-sousuo="icon-sousuo" />
  传入对应的样式，子组件即可获取并使用
  但是只能使用无法修改，如果有其他需求可以自己定义一个class类来操作
  ```

## 5.3组件内部使用组建外部样式的三种方法总结

1. 组件外部通过在标签上写入样式名称的方式，组建内部使用externalClasses接收样式

   ```
     externalClasses:[
       "iconfont",
       "icon-sousuo"
     ],
   ```

2. 直接把样式拷贝进组件的目录中即可使用

3. 组建内部定义属性，即可与父组件互通并修改样式 （不推荐）

   ```
     options: {
       styleIsolation: 'apply-shared'
     },
   ```

## 5.4用户信息授权与获取

1. 当点击某个需要权限的按钮时，调用方法 wx.getSetting ,如果返回对象中scope.userInfo为true，代表当前用户已经授权

   ```javascript
       // 判断用户是否授权
       wx.getSetting({
         success:(res)=> {
           console.log(res, '授权')
           // 说明授权了
           if (res.authSetting['scope.userInfo']) {
             wx.getUserInfo({
               success: (res) => {
                 console.log(res, '获取用户西悉尼')
               }
             })
           }
           //用户未授权
           else {
             this.setData({
               showModal: true
             })
           }
         }
       })
   ```

2. 如果当前用户为授权，就打开自定义的授权弹窗并调用api ,如果成功获取到可以在对象的detail中获取到用户的信息

   ```
   <button class="login" open-type="getUserInfo" bindgetuserinfo="handleGetUserInfo">获取微信授权信息</button>
   
   
     methods: {
       handleGetUserInfo(event) {
         console.log(event,'信息啊啊')
       }
     }
   ```

   {nickName: "Pluto", avatarUrl: "https://wx.qlogo.cn/mmopen/vi_32/F09h1iby0Ot2dns0P…HEs2ibvl9ib7ia0VyFCZ3MGfoYXfckZ4lMffV5GcXFJ5Q/132"} "blog-edit接受数据"

## 5.5发布页面的制作

- 原生组件textarea绑定 input事件必须 是bindInput连写，不能用 ：分割

- 底部控件可以使用css样式控制，当textarea获取焦点时，说明用户要输入内容，此时调用 bindfocus 对应的方法，事件对象的detail中包含了用户输入框的高度，此时把这个高度赋给 底部控件的top值，当失去焦点重新设为0即可

  ```
    },
    // 文本域获取焦点事件，可获取输入栏的高度,注意只在真机有效
    onFocus(event) {
      this.setData({
        footerBottom: event.detail.height
      })
    },
    // 文本域失去焦点事件
    onBlur() {
      this.setData({
        footerBottom: 0
      })
    },
  ```


## 5.6用户上传图片功能

- 点击上传图片的区域时，调用小程序api

  ```javascript
    // 选择图片的函数
    chooseImg() {
      wx.chooseImage({
        count: MAX_IMAGE_NUM - this.data.images.length, //最多可选择几张
        sourceType: ['album', 'camera'], // 图片来源
        sizeType: ['original', 'compressed'], // 所选的图片的尺寸
        success: (res) => {
          // console.log(res.tempFilePaths)
          this.setData({
            images: this.data.images.concat(res.tempFilePaths)
          })
        },
      })
    },
  ```


## 5.7图片的删除功能

- 给图片右上角定位的删除图标绑定事件，并设置data-index传入当前点击图片的序号

- 使用splice方法修改原有数组并setData即可

  ```javascript
    // 删除图片的回调
    onDelImage(event) {
      let images = this.data.images
      images.splice(event.currentTarget.dataset.index,1)
      this.setData({
        images: images,
        selectphoto:this.data.images.length >= 9 ? true : false,
      })
    },
  ```


## 5.8图片的预览功能

- 图片绑定点击事件
- 注意在模拟器中有时无法退出预览，但真机无问题

```
  // 预览图片
  previewImg(event) {
    let src = this.data.images[event.currentTarget.dataset.index]
    wx.previewImage({
      current: src, // 当前显示图片的http链接
      urls: this.data.images // 需要预览的图片http链接列表
    })
  },
```

