# 1.0云开发学习

本地项目地址 D:\Study\云音乐

# 2.0云开发的优势

```
1.云函数支持本地调试，调试云端和调试前端代码是一样的，做到了全栈开发模式

2.可以快速上线

3.可以专注核心业务

4.减少前后端沟通成本

5.无需运维，节约成本

```

## 2.1云开发提供了哪些能力

```
1.云函数:在云端运行的代码。微信私有协议天然鉴权 （开发者可以很方便的获取到用户的openId，云函数相当于小程序的后端部分）
2.云数据库：一个既可以在小程序端操作又可以在云函数中操作的JSON数据库
3.云存储：在云端存储文件，可以在云端控制台可视化管理
4.云调用：基于云函数免鉴权使用小程序开放接口的能力
5.HTTP API：使用HTTP API开发者可以在已有服务器上访问云资源，实现与云开发的互通
```

## 2.2开通云开发

1.[https://mp.weixin.qq.com](https://mp.weixin.qq.com/)登录微信公众平台获取自己的appid

2.点击微信开发工具的左上角云开发按钮

3.点击后的弹窗=》创建环境 =》声明环境名称和环境ID后点击确定即可

## 2.3初始化项目

1.当创建完云环境后可以看见第一个文件夹使用 | 分割后面是对应环境的名称

2.miniprogram目录中的app.js是项目的配置文件，其中env代表当前对应的环境，具体可打开云开发控制台查看（设置=》环境设置=》右侧即可查看）

3.app.js中  traceUser: true  是否记录每个访问小程序的用户，并且以倒叙的形式显示

## 2.4配置tabbar

- 在app.json中输入list即可，之后按照需求配置
- color文本颜色 selectedColor 选中的文本颜色

```
  "tabBar": {
    "color":"#474747",
    "selectedColor":"#d43c43",
    "list": [
      {
      "pagePath": "pages/playlist/playlist",
      "text": "音乐",
      "iconPath": "images/music.png",
      "selectedIconPath": "images/music-actived.png"
    },
      {
      "pagePath": "pages/blog/blog",
      "text": "发现",
      "iconPath": "images/blog.png",
      "selectedIconPath": "images/blog-actived.png"
    },
      {
      "pagePath": "pages/blog/blog",
      "text": "我的",
      "iconPath": "images/profile.png",
      "selectedIconPath": "images/profile-actived.png"
    }
    ]
  },
```

## 2.5配置轮播图

- 注意获取变量需要用双大括号包裹才可以拿到值

- 不加就会变成循环这个字符串

- widthFix代表宽度占满，高度自适应，配合图片宽度100%可以完整显示轮播图

```vue
<swiper indicator-dots="true" autoplay="true" interval="2000" duration="1000">
  <block wx:for="{{swiperImgUrls}}" wx:key="*this">
    <swiper-item>
      <image src="{{item.url}}" mode="widthFix"></image>
    </swiper-item>
  </block>
</swiper>
```

## 2.6组件化的好处

- 高内聚：保证一个段一个单元的代码来解决一个需求
- 低耦合：组件和组件之间减少耦合性，组件相对独立，增强组件的复合型
- 单一职责
- 避免过多参数

## 2.7自定义播放列表组件

1. 注册组件，在components文件夹下新建playlistitem组件

```vue
<view class="playlist-container">
  <image src="{{playlist.picUrl}}" class="playlist-img"></image>
  <text class="playlist-playcount">{{playlist.playCount}}</text>
  <view class="playlist-name">{{playlist.name}}</view>
</view>
```

2. 接受父组件传过来的参数对象

```
  properties: {
    playlist: {
      type: Object,
      value: {}
    }
  },

```

3.写入样式

注意由于每个组件占一行的三分之一，因此设定宽度来实现这个效果而不是flex：1

父组件设置 display:flex 和 flex-wrap:wrap换行即可



右上角的耳机图标的设置：给容器设置了背景图片，不重复，位置为left和center，也就是靠左和居中

```css
.playlist-container {
  width: 220rpx;
  position: relative;
  padding-bottom: 20rpx;
}

.playlist-img {
  width: 100%;
  height: 220rpx;
  border-radius: 6rpx;
}

.playlist-playcount {
  font-size: 24rpx;
  color: #fff;
  text-shadow: 1px 0 0 rgba(0, 0, 0, 0.15);
  position: absolute;
  right: 10rpx;
  top: 4rpx;
  padding-left: 26rpx;
  background: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMiAyMCI+PGcgb3BhY2l0eT0iLjE1Ij48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGZpbGw9IiMwNDAwMDAiIGQ9Im0yMiAxNi43NzdjMCAxLjIzMy0xLjEyMSAyLjIzMy0yLjUwNiAyLjIzMy0xLjM4NCAwLTIuNTA2LTEtMi41MDYtMi4yMzN2LTIuNTUzYzAtMS4yMzQgMS4xMjItMi4yMzMgMi41MDYtMi4yMzMuMTc0IDAgLjM0My4wMTcuNTA2LjA0NnYtMS4zN2gtLjAzM2MuMDE3LS4yMi4wMzMtLjQ0MS4wMzMtLjY2NiAwLTQuNDE4LTMuNTgyLTgtOC04LTQuNDE4IDAtOCAzLjU4Mi04IDggMCAuMjI1LjAxNi40NDYuMDM0LjY2NmgtLjAzNHYxLjM3Yy4xNjMtLjAyOS4zMzMtLjA0Ni41MDUtLjA0NiAxLjM4NCAwIDIuNTA2Ljk5OSAyLjUwNiAyLjIzM3YyLjU1M2MwIDEuMjMzLTEuMTIyIDIuMjMzLTIuNTA2IDIuMjMzcy0yLjUwNS0uOTk5LTIuNTA1LTIuMjMzdi0yLjU1M2MwLS4yNTguMDU5LS41MDEuMTQ4LS43My0uMDg1LS4xNDgtLjE0OC0uMzEtLjE0OC0uNDkzdi0yLjY2N2MwLS4wMjMuMDEyLS4wNDMuMDEzLS4wNjctLjAwNC0uMDg4LS4wMTMtLjE3Ni0uMDEzLS4yNjYgMC01LjUyMyA0LjQ3Ny0xMCAxMC0xMCA1LjUyMyAwIDEwIDQuNDc3IDEwIDEwIDAgLjA5LS4wMDkuMTc4LS4wMTQuMjY2LjAwMi4wMjQuMDE0LjA0NC4wMTQuMDY3djJjMCAuMzA2LS4xNDUuNTY5LS4zNi43NTMuMjI0LjMzNC4zNi43Mi4zNiAxLjEzOHYyLjU1MiIvPjwvZz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGZpbGw9IiNmZmYiIGQ9Im0yMCAxNi43NzdjMCAxLjIzMy0xLjEyMSAyLjIzMy0yLjUwNiAyLjIzMy0xLjM4NCAwLTIuNTA2LTEtMi41MDYtMi4yMzN2LTIuNTUzYzAtMS4yMzQgMS4xMjItMi4yMzMgMi41MDYtMi4yMzMuMTc0IDAgLjM0My4wMTcuNTA2LjA0NnYtMS4zN2gtLjAzM2MuMDE3LS4yMi4wMzMtLjQ0MS4wMzMtLjY2NiAwLTQuNDE4LTMuNTgyLTgtOC04LTQuNDE4IDAtOCAzLjU4Mi04IDggMCAuMjI1LjAxNi40NDYuMDM0LjY2NmgtLjAzNHYxLjM3Yy4xNjMtLjAyOS4zMzMtLjA0Ni41MDUtLjA0NiAxLjM4NCAwIDIuNTA2Ljk5OSAyLjUwNiAyLjIzM3YyLjU1M2MwIDEuMjMzLTEuMTIyIDIuMjMzLTIuNTA2IDIuMjMzcy0yLjUwNS0uOTk5LTIuNTA1LTIuMjMzdi0yLjU1M2MwLS4yNTguMDU5LS41MDEuMTQ4LS43My0uMDg1LS4xNDgtLjE0OC0uMzEtLjE0OC0uNDkzdi0yLjY2N2MwLS4wMjMuMDEyLS4wNDMuMDEzLS4wNjctLjAwNC0uMDg4LS4wMTMtLjE3Ni0uMDEzLS4yNjYgMC01LjUyMyA0LjQ3Ny0xMCAxMC0xMCA1LjUyMyAwIDEwIDQuNDc3IDEwIDEwIDAgLjA5LS4wMDkuMTc4LS4wMTQuMjY2LjAwMi4wMjQuMDE0LjA0NC4wMTQuMDY3djJjMCAuMzA2LS4xNDUuNTY5LS4zNi43NTMuMjI0LjMzNC4zNi43Mi4zNiAxLjEzOHYyLjU1MiIvPjwvc3ZnPg==) no-repeat;
  background-position: left;
  background-size: 26rpx;
}

.playlist-name {
  font-size: 26rpx;
  line-height: 1.2;
  padding: 2px 0 0 6px;
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 2;
  overflow: hidden;
  text-overflow: ellipsis;
}

```

## 2.8转换组件上的播放数量

定义一个方法来转换

- 首先把小数点后的数字去掉
- 如果小于6位则不操作
- 如果大于等于6小于等于8即在一亿以下，十万以上则把万以下的数字切出来例如15422切出5422，切的数量根据传的point决定
- 返回传入数字除以10000并取整，可得万的数量，拼接上刚才切出的数字则可得 xx.xx万

```javascript
    // 根据传入的数值把数字转为带单位
    _tranNumber(num,point=2) {
      // 获取Num
      let newNum = num.toString().split(".")[0]
      if (newNum.length < 6) {
        return newNum
      } else if (newNum.length >= 6 && newNum.length <= 8) {
        let decimal = newNum.substring(newNum.length - 4, newNum.length - 4 + point)
        console.log(decimal,'decimal')
        return (parseFloat(parseInt(num / 10000) + '.' + decimal)) + '万'
      }
      else if (newNum.length > 8) {
        let decimal = newNum.substring(newNum.length - 8, newNum.length-8+point)
        return parseFloat(parseInt(num/100000000)+ '.' + decimal) + '亿'
      }
    }
```

observers是组件内部的属性，可以监听值的改变，因此监听传入的数量，并转化为可读格式后赋值给data内部的变量。注意不能在这里直接修改自己，不然会无限变化并监听变化造成死循环

```
  observers: {
    ["playlist.playCount"](val){
      console.log(val,'val')
      console.log(this._tranNumber(val,2),'@@@')
      // return this._tranNumber(val, 3)
      this.setData({
        _count: this._tranNumber(val, 2)
      })
    }
  },
```

# 3.0开发中的常见问题

## 3.1 wx:for循环

1. wx:for对应的数组/对象需要用 {{}} 双大括号包裹才可
2. wx:key 如果循环的数组是静态的，可以忽略，如果是动态的数组或者要对数组进行操作，则需要对应数组中的一个独一无二的属性，例如id



## 3.2Promise

1. promise.all 代表所有的请求都成功才会成功 ,但是不会阻止失败之后的任务的执行

   - 当文件上传的时候推荐使用，当所有的文件都上传成功才会执行回调

   ```
   Promise.all([promise请求,promise请求]).then(res=> {  console.log(res)  })
   ```


2. promise.race  代表有一个请求完成后就成功

   - 可以验证超时，把请求和一个定时器放在一起执行，如果定时器先执行说明请求超时（更慢）

   ```
   Promise.race([promise请求,promise请求]).then(res=> {  console.log(res)  })
   当其中一个请求完成就会
   ```


## 3.3云函数初体验

1. 新建一个云函数，推荐直接右键创建

2. ```
   安装依赖
   npm i request --save
   npm i request-promise --save
   ```

   调用接口发送请求

   - 注意需要先cloud.init()初始化
   - const db = cloud.database() 导入云数据库
   - 通过request-promise发送请求获取数据 ，前面要加上await
   - 获取到数据后需要JSON.parse（res）把返回的数据转换为对象，有时返回的是JSON字符串，因此用于保险
   - 获取到数据后通过数据库的add方法插入到云数据库中，注意方法前要加上 awiat  ( await db.collection("playlist").add )
   - 要想插入数据需要在add内部对象定义一个data才可插入数据，单独写add（{}）无效
   - 完成后上传到云端并在云端测试

   ```vue
   // 云函数入口文件
   const cloud = require('wx-server-sdk')
   
   cloud.init()
   
   const db = cloud.database()
   
   const rp = require("request-promise")
   
   const URL = 'http://musicapi.xiecheng.live/personalized'
   
   // 云函数入口函数
   exports.main = async (event, context) => {
     const wxContext = cloud.getWXContext()
     let playlist = await rp(URL).then(res=> {
       return JSON.parse(res).result
     })
     console.log(playlist)
     for (let i = 0; i < playlist.length;i++) {
       await db.collection("playlist").add({
         data: {
           ...playlist[i],
           createTime: db.serverDate()
         }
       }).then(res=>{
         console.log('插入成功')
       }).catch(err=> {
         console.log(err,'err')
       })
     }
     
   
     return {
       event,
       openid: wxContext.OPENID,
       appid: wxContext.APPID,
       unionid: wxContext.UNIONID,
     }
   }
   ```

## 3.4新增去重操作

- 注意  db.collection("playlist").get()  获取到的数据需要再 .data才能获取到要操作的数组！

```vue
// 云函数入口文件
const cloud = require('wx-server-sdk')

cloud.init()

const db = cloud.database()

const rp = require("request-promise")

const URL = 'http://musicapi.xiecheng.live/personalized'

const getDb = db.collection("playlist")

// 云函数入口函数
exports.main = async(event, context) => {
  // 获取数据库中的已有数据
  let list = await getDb.get()
  console.log(list, '输出list')
  // 定义一个数组用于插入数据
  let newArr = []
  // 接口获取的新数据
  let playlist = await rp(URL).then(res => {
    return JSON.parse(res).result
  })
  for (let i = 0; i < playlist.length; i++) {
    let flag = true
    for (let j = 0; j < list.data.length; j++) {
      if (playlist[i].id === list.data[i].id) {
        flag = false
      }
    }
    if (flag) {
      newArr.push(playlist[i])
    }
  }

  console.log(newArr, '输出newArr')
  for (let i = 0; i < newArr.length; i++) {
    await getDb.add({
      data: {
        ...newArr[i],
        createTime: db.serverDate()
      }
    }).then(res => {
      console.log('插入成功')
    }).catch(err => {
      console.log(err, 'err')
    })
  }


  return
}
```

## 3.5分段取出数据库的所有数据

- 云数据库有限制，一次只能取出100条数据

- 因此获取总数，然后分次数拿到每次返回的promise对象

- 通过promise.all 和 reduce方法拼接返回的参数

  ```vue
    // 获取数据库中的已有数据
    let countResult = await getDb.count()
    // 拿到数据总数
    let total = countResult.total
    console.log(total,'total')
    // 获取的次数
    let batchTimes = Math.ceil(total/10)
    let tasks = []
    for (let i=0;i<batchTimes;i++) {
      // 这里不加await因为promise.all需要 promise对象
      let promise = getDb.skip(i*MAX_LIMIT).limit(MAX_LIMIT).get()
      tasks.push(promise)
    }
    let list = {
      data: []
    }
    console.log(tasks, '输出tasks')
    // 说明数据库不为空
    if (tasks.length > 0) {
      // await获取Promise.all的结果
      list = (await Promise.all(tasks)).reduce((acc,cur)=> {
        return {
          data: acc.data.concat(cur.data)
        }
      })
    }
    console.log(list,'输出list')
  ```

  ### 3.6触发器的使用

  - 触发器可以设置在某个时间点调用云函数

  - 在云函数的目录下新建conifg.json文件，写入下列代码

    ```
    {
      "triggers": [
        {
          "name": "myTrigger",
          "type": "timer",
          "config": "0 0 10,14,16,23 * * * *"
        }
      ]
    }
    ```

    完成后必须上传触发器才可生效

    config对应的是时间的格式 具体参考

    <https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/functions/triggers.html>

    本次含义为 每天的10点2点4点半夜11点触发一次

## 3.7获取音乐的云函数

- 调用定义的音乐云函数

- event就是你传入的data对象

- ```
  // 云函数入口文件
  const cloud = require('wx-server-sdk')
  
  cloud.init()
  
  // 云函数入口函数
  exports.main = async(event, context) => {
    // 获取音乐数据
    return await cloud.database().collection('playlist').skip(event.start).limit(event.count).orderBy('createTime', 'desc').get().then(res => {
      return res
    })
  
  }
  ```

  在页面的js中应用

```javascript
  _getPlayList() {
    wx.showLoading({
      title: '玩命加载中~',
    })
    // 获取音乐列表,start动态根据数组的长度变化
    wx.cloud.callFunction({
      name: 'music',
      data: {
        start: this.data.playlist.length,
        count: MAX_LIMIT
      }
    }).then(res => {
      console.log(res, '输出结果')
      this.setData({
        playlist: this.data.playlist.concat(res.result.data) 
      })
      // 请求完成隐藏下拉小点
      wx.stopPullDownRefresh()
      wx.hideLoading()
    }).catch(err => {
      wx.hideLoading()
      console.log(err, 'err')
    })
  },
```

## 3.8使用tcb-router管理云函数

- 为了解决云函数上限50个，因此使用tcb-router来管理相同类型的云函数

- 安装tab-router   npm i tcb-router --save

- 新建tabRouter云函数

- const app = new TcbRouter({event}) 必须传入event不然返回值为空

- app.router 定义路由

- 必须返回   return app.serve()

- 调用方法

  ```javascript
      wx.cloud.callFunction({ 
        name: 'tcbRouter',
        data: {
        // 路由名称
          $url: 'music'
        },
      }).then(res=> { 
        console.log(res,'res')
      })
  ```



  ```javascript
  // 云函数入口文件
  const cloud = require('wx-server-sdk')
  const TcbRouter = require('tcb-router')
  
  cloud.init()
  
  // 云函数入口函数
  exports.main = async(event, context) => {
    // 传入event参数，这样tab就会自动处理参数的转发
    const app = new TcbRouter({event})
  
    app.use(async(ctx, next) => {
      ctx.data = {}
      ctx.data.openId = event.userInfo.openId
      ctx.data.event = event
      await next()
    })
  
    app.router('music', async(ctx, next) => {
      ctx.data.musicName = '义勇军进行曲'
      await next()
    }, async(ctx, next) => {
      ctx.data.musicType = '国歌'
      ctx.body = {
          data: ctx.data
        }
    })
  
    app.router('movie', async(ctx, next) => {
      ctx.data.movieName = "千与千寻"
      await next()
    }, async(ctx, next) => {
      ctx.data.movieType = "日漫"
      ctx.body = {
        data: ctx.data
      }
    })
  
    return app.serve()
  }
  ```


## 3.9tcb-router的简单使用

- 云函数使用tcb-router

- 安装导入 tcb-router 后必须初始化并传入事件对象

- 最后要 返回 app.serve ()

  ```javascript
  
  // 云函数入口函数
  exports.main = async(event, context) => {
    const app = new TcbRouter({
      event
    })
    // 全局中间件
    app.use(async(ctx, next) => {
      await next()
    })
    app.router('music', async(ctx, next) => {
      // 获取音乐数据
      ctx.body = await cloud.database().collection('playlist').skip(event.start).limit(event.count).orderBy('createTime', 'desc').get().then(res => {
        return res
      })
      await next()
    })
  
    // 获取音乐数据
    // return await cloud.database().collection('playlist').skip(event.start).limit(event.count).orderBy('createTime', 'desc').get().then(res => {
    //   return res
    // })
    return app.serve()
  }
  ```

  使用该云函数

  - 如果使用了 tcb-router 的路由

  - 则需要传入 $url 对应路由的名称才可以调用

  ```javascript
      wx.cloud.callFunction({
        name: 'music',
        data: {
          $url:'music',
          start: this.data.playlist.length,
          count: MAX_LIMIT
        }
      }).then(res => {
        console.log(res, '输出结果')
        this.setData({
          playlist: this.data.playlist.concat(res.result.data) 
        })
        // 请求完成隐藏下拉小点
        wx.stopPullDownRefresh()
        wx.hideLoading()
      }).catch(err => {
        wx.hideLoading()
        console.log(err, 'err')
      })
  ```




## 3.10 小程序拓展

- 点击事件时对象的 target 和 currenttarget的区别
- target是你点击的元素，currenttarget是你绑定事件的元素