# 1.0云开发学习

本地项目地址 D:\Study\云音乐

# 2.0云开发的优势

```
1.云函数支持本地调试，调试云端和调试前端代码是一样的，做到了全栈开发模式

2.可以快速上线

3.可以专注核心业务

4.减少前后端沟通成本

5.无需运维，节约成本

```

## 2.1云开发提供了哪些能力

```
1.云函数:在云端运行的代码。微信私有协议天然鉴权 （开发者可以很方便的获取到用户的openId，云函数相当于小程序的后端部分）
2.云数据库：一个既可以在小程序端操作又可以在云函数中操作的JSON数据库
3.云存储：在云端存储文件，可以在云端控制台可视化管理
4.云调用：基于云函数免鉴权使用小程序开放接口的能力
5.HTTP API：使用HTTP API开发者可以在已有服务器上访问云资源，实现与云开发的互通
```

## 2.2开通云开发

1.[https://mp.weixin.qq.com](https://mp.weixin.qq.com/)登录微信公众平台获取自己的appid

2.点击微信开发工具的左上角云开发按钮

3.点击后的弹窗=》创建环境 =》声明环境名称和环境ID后点击确定即可

## 2.3初始化项目

1.当创建完云环境后可以看见第一个文件夹使用 | 分割后面是对应环境的名称

2.miniprogram目录中的app.js是项目的配置文件，其中env代表当前对应的环境，具体可打开云开发控制台查看（设置=》环境设置=》右侧即可查看）

3.app.js中  traceUser: true  是否记录每个访问小程序的用户，并且以倒叙的形式显示

## 2.4配置tabbar

- 在app.json中输入list即可，之后按照需求配置
- color文本颜色 selectedColor 选中的文本颜色

```
  "tabBar": {
    "color":"#474747",
    "selectedColor":"#d43c43",
    "list": [
      {
      "pagePath": "pages/playlist/playlist",
      "text": "音乐",
      "iconPath": "images/music.png",
      "selectedIconPath": "images/music-actived.png"
    },
      {
      "pagePath": "pages/blog/blog",
      "text": "发现",
      "iconPath": "images/blog.png",
      "selectedIconPath": "images/blog-actived.png"
    },
      {
      "pagePath": "pages/blog/blog",
      "text": "我的",
      "iconPath": "images/profile.png",
      "selectedIconPath": "images/profile-actived.png"
    }
    ]
  },
```

## 2.5配置轮播图

- 注意获取变量需要用双大括号包裹才可以拿到值

- 不加就会变成循环这个字符串

- widthFix代表宽度占满，高度自适应，配合图片宽度100%可以完整显示轮播图

```vue
<swiper indicator-dots="true" autoplay="true" interval="2000" duration="1000">
  <block wx:for="{{swiperImgUrls}}" wx:key="*this">
    <swiper-item>
      <image src="{{item.url}}" mode="widthFix"></image>
    </swiper-item>
  </block>
</swiper>
```

## 2.6组件化的好处

- 高内聚：保证一个段一个单元的代码来解决一个需求
- 低耦合：组件和组件之间减少耦合性，组件相对独立，增强组件的复合型
- 单一职责
- 避免过多参数

## 2.7自定义播放列表组件

1. 注册组件，在components文件夹下新建playlistitem组件

```vue
<view class="playlist-container">
  <image src="{{playlist.picUrl}}" class="playlist-img"></image>
  <text class="playlist-playcount">{{playlist.playCount}}</text>
  <view class="playlist-name">{{playlist.name}}</view>
</view>
```

2. 接受父组件传过来的参数对象

```
  properties: {
    playlist: {
      type: Object,
      value: {}
    }
  },

```

3.写入样式

注意由于每个组件占一行的三分之一，因此设定宽度来实现这个效果而不是flex：1

父组件设置 display:flex 和 flex-wrap:wrap换行即可



右上角的耳机图标的设置：给容器设置了背景图片，不重复，位置为left和center，也就是靠左和居中

```css
.playlist-container {
  width: 220rpx;
  position: relative;
  padding-bottom: 20rpx;
}

.playlist-img {
  width: 100%;
  height: 220rpx;
  border-radius: 6rpx;
}

.playlist-playcount {
  font-size: 24rpx;
  color: #fff;
  text-shadow: 1px 0 0 rgba(0, 0, 0, 0.15);
  position: absolute;
  right: 10rpx;
  top: 4rpx;
  padding-left: 26rpx;
  background: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMiAyMCI+PGcgb3BhY2l0eT0iLjE1Ij48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGZpbGw9IiMwNDAwMDAiIGQ9Im0yMiAxNi43NzdjMCAxLjIzMy0xLjEyMSAyLjIzMy0yLjUwNiAyLjIzMy0xLjM4NCAwLTIuNTA2LTEtMi41MDYtMi4yMzN2LTIuNTUzYzAtMS4yMzQgMS4xMjItMi4yMzMgMi41MDYtMi4yMzMuMTc0IDAgLjM0My4wMTcuNTA2LjA0NnYtMS4zN2gtLjAzM2MuMDE3LS4yMi4wMzMtLjQ0MS4wMzMtLjY2NiAwLTQuNDE4LTMuNTgyLTgtOC04LTQuNDE4IDAtOCAzLjU4Mi04IDggMCAuMjI1LjAxNi40NDYuMDM0LjY2NmgtLjAzNHYxLjM3Yy4xNjMtLjAyOS4zMzMtLjA0Ni41MDUtLjA0NiAxLjM4NCAwIDIuNTA2Ljk5OSAyLjUwNiAyLjIzM3YyLjU1M2MwIDEuMjMzLTEuMTIyIDIuMjMzLTIuNTA2IDIuMjMzcy0yLjUwNS0uOTk5LTIuNTA1LTIuMjMzdi0yLjU1M2MwLS4yNTguMDU5LS41MDEuMTQ4LS43My0uMDg1LS4xNDgtLjE0OC0uMzEtLjE0OC0uNDkzdi0yLjY2N2MwLS4wMjMuMDEyLS4wNDMuMDEzLS4wNjctLjAwNC0uMDg4LS4wMTMtLjE3Ni0uMDEzLS4yNjYgMC01LjUyMyA0LjQ3Ny0xMCAxMC0xMCA1LjUyMyAwIDEwIDQuNDc3IDEwIDEwIDAgLjA5LS4wMDkuMTc4LS4wMTQuMjY2LjAwMi4wMjQuMDE0LjA0NC4wMTQuMDY3djJjMCAuMzA2LS4xNDUuNTY5LS4zNi43NTMuMjI0LjMzNC4zNi43Mi4zNiAxLjEzOHYyLjU1MiIvPjwvZz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGZpbGw9IiNmZmYiIGQ9Im0yMCAxNi43NzdjMCAxLjIzMy0xLjEyMSAyLjIzMy0yLjUwNiAyLjIzMy0xLjM4NCAwLTIuNTA2LTEtMi41MDYtMi4yMzN2LTIuNTUzYzAtMS4yMzQgMS4xMjItMi4yMzMgMi41MDYtMi4yMzMuMTc0IDAgLjM0My4wMTcuNTA2LjA0NnYtMS4zN2gtLjAzM2MuMDE3LS4yMi4wMzMtLjQ0MS4wMzMtLjY2NiAwLTQuNDE4LTMuNTgyLTgtOC04LTQuNDE4IDAtOCAzLjU4Mi04IDggMCAuMjI1LjAxNi40NDYuMDM0LjY2NmgtLjAzNHYxLjM3Yy4xNjMtLjAyOS4zMzMtLjA0Ni41MDUtLjA0NiAxLjM4NCAwIDIuNTA2Ljk5OSAyLjUwNiAyLjIzM3YyLjU1M2MwIDEuMjMzLTEuMTIyIDIuMjMzLTIuNTA2IDIuMjMzcy0yLjUwNS0uOTk5LTIuNTA1LTIuMjMzdi0yLjU1M2MwLS4yNTguMDU5LS41MDEuMTQ4LS43My0uMDg1LS4xNDgtLjE0OC0uMzEtLjE0OC0uNDkzdi0yLjY2N2MwLS4wMjMuMDEyLS4wNDMuMDEzLS4wNjctLjAwNC0uMDg4LS4wMTMtLjE3Ni0uMDEzLS4yNjYgMC01LjUyMyA0LjQ3Ny0xMCAxMC0xMCA1LjUyMyAwIDEwIDQuNDc3IDEwIDEwIDAgLjA5LS4wMDkuMTc4LS4wMTQuMjY2LjAwMi4wMjQuMDE0LjA0NC4wMTQuMDY3djJjMCAuMzA2LS4xNDUuNTY5LS4zNi43NTMuMjI0LjMzNC4zNi43Mi4zNiAxLjEzOHYyLjU1MiIvPjwvc3ZnPg==) no-repeat;
  background-position: left;
  background-size: 26rpx;
}

.playlist-name {
  font-size: 26rpx;
  line-height: 1.2;
  padding: 2px 0 0 6px;
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 2;
  overflow: hidden;
  text-overflow: ellipsis;
}

```

## 2.8转换组件上的播放数量

定义一个方法来转换

- 首先把小数点后的数字去掉
- 如果小于6位则不操作
- 如果大于等于6小于等于8即在一亿以下，十万以上则把万以下的数字切出来例如15422切出5422，切的数量根据传的point决定
- 返回传入数字除以10000并取整，可得万的数量，拼接上刚才切出的数字则可得 xx.xx万

```javascript
    // 根据传入的数值把数字转为带单位
    _tranNumber(num,point=2) {
      // 获取Num
      let newNum = num.toString().split(".")[0]
      if (newNum.length < 6) {
        return newNum
      } else if (newNum.length >= 6 && newNum.length <= 8) {
        let decimal = newNum.substring(newNum.length - 4, newNum.length - 4 + point)
        console.log(decimal,'decimal')
        return (parseFloat(parseInt(num / 10000) + '.' + decimal)) + '万'
      }
      else if (newNum.length > 8) {
        let decimal = newNum.substring(newNum.length - 8, newNum.length-8+point)
        return parseFloat(parseInt(num/100000000)+ '.' + decimal) + '亿'
      }
    }
```

observers是组件内部的属性，可以监听值的改变，因此监听传入的数量，并转化为可读格式后赋值给data内部的变量。注意不能在这里直接修改自己，不然会无限变化并监听变化造成死循环

```
  observers: {
    ["playlist.playCount"](val){
      console.log(val,'val')
      console.log(this._tranNumber(val,2),'@@@')
      // return this._tranNumber(val, 3)
      this.setData({
        _count: this._tranNumber(val, 2)
      })
    }
  },
```

# 3.0开发中的常见问题

## 3.1 wx:for循环

1. wx:for对应的数组/对象需要用 {{}} 双大括号包裹才可
2. wx:key 如果循环的数组是静态的，可以忽略，如果是动态的数组或者要对数组进行操作，则需要对应数组中的一个独一无二的属性，例如id



## 3.2Promise

1. promise.all 代表所有的请求都成功才会成功 ,但是不会阻止失败之后的任务的执行

   - 当文件上传的时候推荐使用，当所有的文件都上传成功才会执行回调

   ```
   Promise.all([promise请求,promise请求]).then(res=> {  console.log(res)  })
   ```


2. promise.race  代表有一个请求完成后就成功

   - 可以验证超时，把请求和一个定时器放在一起执行，如果定时器先执行说明请求超时（更慢）

   ```
   Promise.race([promise请求,promise请求]).then(res=> {  console.log(res)  })
   当其中一个请求完成就会
   ```


## 3.3云函数初体验

1. 新建一个云函数，推荐直接右键创建

2. ```
   安装依赖
   npm i request --save
   npm i request-promise --save
   ```

   调用接口发送请求

   - 注意需要先cloud.init()初始化
   - const db = cloud.database() 导入云数据库
   - 通过request-promise发送请求获取数据 ，前面要加上await
   - 获取到数据后需要JSON.parse（res）把返回的数据转换为对象，有时返回的是JSON字符串，因此用于保险
   - 获取到数据后通过数据库的add方法插入到云数据库中，注意方法前要加上 awiat  ( await db.collection("playlist").add )
   - 要想插入数据需要在add内部对象定义一个data才可插入数据，单独写add（{}）无效
   - 完成后上传到云端并在云端测试

   ```vue
   // 云函数入口文件
   const cloud = require('wx-server-sdk')
   
   cloud.init()
   
   const db = cloud.database()
   
   const rp = require("request-promise")
   
   const URL = 'http://musicapi.xiecheng.live/personalized'
   
   // 云函数入口函数
   exports.main = async (event, context) => {
     const wxContext = cloud.getWXContext()
     let playlist = await rp(URL).then(res=> {
       return JSON.parse(res).result
     })
     console.log(playlist)
     for (let i = 0; i < playlist.length;i++) {
       await db.collection("playlist").add({
         data: {
           ...playlist[i],
           createTime: db.serverDate()
         }
       }).then(res=>{
         console.log('插入成功')
       }).catch(err=> {
         console.log(err,'err')
       })
     }
     
   
     return {
       event,
       openid: wxContext.OPENID,
       appid: wxContext.APPID,
       unionid: wxContext.UNIONID,
     }
   }
   ```

## 3.4新增去重操作

- 注意  db.collection("playlist").get()  获取到的数据需要再 .data才能获取到要操作的数组！

```vue
// 云函数入口文件
const cloud = require('wx-server-sdk')

cloud.init()

const db = cloud.database()

const rp = require("request-promise")

const URL = 'http://musicapi.xiecheng.live/personalized'

const getDb = db.collection("playlist")

// 云函数入口函数
exports.main = async(event, context) => {
  // 获取数据库中的已有数据
  let list = await getDb.get()
  console.log(list, '输出list')
  // 定义一个数组用于插入数据
  let newArr = []
  // 接口获取的新数据
  let playlist = await rp(URL).then(res => {
    return JSON.parse(res).result
  })
  for (let i = 0; i < playlist.length; i++) {
    let flag = true
    for (let j = 0; j < list.data.length; j++) {
      if (playlist[i].id === list.data[i].id) {
        flag = false
      }
    }
    if (flag) {
      newArr.push(playlist[i])
    }
  }

  console.log(newArr, '输出newArr')
  for (let i = 0; i < newArr.length; i++) {
    await getDb.add({
      data: {
        ...newArr[i],
        createTime: db.serverDate()
      }
    }).then(res => {
      console.log('插入成功')
    }).catch(err => {
      console.log(err, 'err')
    })
  }


  return
}
```

## 3.5分段取出数据库的所有数据

- 云数据库有限制，一次只能取出100条数据

- 因此获取总数，然后分次数拿到每次返回的promise对象

- 通过promise.all 和 reduce方法拼接返回的参数

  ```vue
    // 获取数据库中的已有数据
    let countResult = await getDb.count()
    // 拿到数据总数
    let total = countResult.total
    console.log(total,'total')
    // 获取的次数
    let batchTimes = Math.ceil(total/10)
    let tasks = []
    for (let i=0;i<batchTimes;i++) {
      // 这里不加await因为promise.all需要 promise对象
      let promise = getDb.skip(i*MAX_LIMIT).limit(MAX_LIMIT).get()
      tasks.push(promise)
    }
    let list = {
      data: []
    }
    console.log(tasks, '输出tasks')
    // 说明数据库不为空
    if (tasks.length > 0) {
      // await获取Promise.all的结果
      list = (await Promise.all(tasks)).reduce((acc,cur)=> {
        return {
          data: acc.data.concat(cur.data)
        }
      })
    }
    console.log(list,'输出list')
  ```

  ### 3.6触发器的使用

  - 触发器可以设置在某个时间点调用云函数

  - 在云函数的目录下新建conifg.json文件，写入下列代码

    ```
    {
      "triggers": [
        {
          "name": "myTrigger",
          "type": "timer",
          "config": "0 0 10,14,16,23 * * * *"
        }
      ]
    }
    ```

    完成后必须上传触发器才可生效

    config对应的是时间的格式 具体参考

    <https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/functions/triggers.html>

    本次含义为 每天的10点2点4点半夜11点触发一次

## 3.7获取音乐的云函数

- 调用定义的音乐云函数

- event就是你传入的data对象

- ```
  // 云函数入口文件
  const cloud = require('wx-server-sdk')
  
  cloud.init()
  
  // 云函数入口函数
  exports.main = async(event, context) => {
    // 获取音乐数据
    return await cloud.database().collection('playlist').skip(event.start).limit(event.count).orderBy('createTime', 'desc').get().then(res => {
      return res
    })
  
  }
  ```

  在页面的js中应用

```javascript
  _getPlayList() {
    wx.showLoading({
      title: '玩命加载中~',
    })
    // 获取音乐列表,start动态根据数组的长度变化
    wx.cloud.callFunction({
      name: 'music',
      data: {
        start: this.data.playlist.length,
        count: MAX_LIMIT
      }
    }).then(res => {
      console.log(res, '输出结果')
      this.setData({
        playlist: this.data.playlist.concat(res.result.data) 
      })
      // 请求完成隐藏下拉小点
      wx.stopPullDownRefresh()
      wx.hideLoading()
    }).catch(err => {
      wx.hideLoading()
      console.log(err, 'err')
    })
  },
```

## 3.8使用tcb-router管理云函数

- 为了解决云函数上限50个，因此使用tcb-router来管理相同类型的云函数

- 安装tab-router   npm i tcb-router --save

- 新建tabRouter云函数

- const app = new TcbRouter({event}) 必须传入event不然返回值为空

- app.router 定义路由

- 必须返回   return app.serve()

- 调用方法

  ```javascript
      wx.cloud.callFunction({ 
        name: 'tcbRouter',
        data: {
        // 路由名称
          $url: 'music'
        },
      }).then(res=> { 
        console.log(res,'res')
      })
  ```



  ```javascript
  // 云函数入口文件
  const cloud = require('wx-server-sdk')
  const TcbRouter = require('tcb-router')
  
  cloud.init()
  
  // 云函数入口函数
  exports.main = async(event, context) => {
    // 传入event参数，这样tab就会自动处理参数的转发
    const app = new TcbRouter({event})
  
    app.use(async(ctx, next) => {
      ctx.data = {}
      ctx.data.openId = event.userInfo.openId
      ctx.data.event = event
      await next()
    })
  
    app.router('music', async(ctx, next) => {
      ctx.data.musicName = '义勇军进行曲'
      await next()
    }, async(ctx, next) => {
      ctx.data.musicType = '国歌'
      ctx.body = {
          data: ctx.data
        }
    })
  
    app.router('movie', async(ctx, next) => {
      ctx.data.movieName = "千与千寻"
      await next()
    }, async(ctx, next) => {
      ctx.data.movieType = "日漫"
      ctx.body = {
        data: ctx.data
      }
    })
  
    return app.serve()
  }
  ```


## 3.9tcb-router的简单使用

- 云函数使用tcb-router

- 安装导入 tcb-router 后必须初始化并传入事件对象

- 最后要 返回 app.serve ()

  ```javascript
  
  // 云函数入口函数
  exports.main = async(event, context) => {
    const app = new TcbRouter({
      event
    })
    // 全局中间件
    app.use(async(ctx, next) => {
      await next()
    })
    app.router('music', async(ctx, next) => {
      // 获取音乐数据
      ctx.body = await cloud.database().collection('playlist').skip(event.start).limit(event.count).orderBy('createTime', 'desc').get().then(res => {
        return res
      })
      await next()
    })
  
    // 获取音乐数据
    // return await cloud.database().collection('playlist').skip(event.start).limit(event.count).orderBy('createTime', 'desc').get().then(res => {
    //   return res
    // })
    return app.serve()
  }
  ```

  使用该云函数

  - 如果使用了 tcb-router 的路由

  - 则需要传入 $url 对应路由的名称才可以调用

  ```javascript
      wx.cloud.callFunction({
        name: 'music',
        data: {
          $url:'music',
          start: this.data.playlist.length,
          count: MAX_LIMIT
        }
      }).then(res => {
        console.log(res, '输出结果')
        this.setData({
          playlist: this.data.playlist.concat(res.result.data) 
        })
        // 请求完成隐藏下拉小点
        wx.stopPullDownRefresh()
        wx.hideLoading()
      }).catch(err => {
        wx.hideLoading()
        console.log(err, 'err')
      })
  ```




## 3.10 小程序拓展

- 点击事件时对象的 target 和 currenttarget的区别
- target是你点击的元素，currenttarget是你绑定事件的元素

# 4.0播放页面制作

## 4.1进入歌曲列表时把数据存入本地

- 进入时会带入playlistId，也就是这个歌曲目录的id，根据云函数获取到对应的歌曲目录，并存入本地

```javascript
  _getMusicList() {
    wx.cloud.callFunction({
      name: 'music',
      data: {
        playlistId: this.data.playlistId,
        $url: 'musiclist'
      }
    }).then(res => {
      const pl = res.result.playlist
      this.setData({
        musiclist: pl.tracks,
        listInfo: {
          coverImgUrl: pl.coverImgUrl,
          name: pl.name
        }
      })
      this._setMusicList()
      wx.hideLoading()
      console.log(res, '输出结果')
    }).catch(err => {
      wx.hideLoading()
      console.log(err, '错误输出')
    })
  },
  _setMusicList() {
    // 同步的把歌曲列表数据存入本地
    wx.setStorageSync('musiclist', this.data.musiclist)
  },
```

## 4.2点击歌曲列表中的某一项高亮并进入详情页

- 定义一个列表组件，把歌曲列表的数据传入，循环渲染歌曲列表。
- 顶部高斯模糊背景加一张图片
- 相当于遮罩层在最下方，容器在遮罩层上方，设置了背景图片但是是模糊的，并且有透明度，因此可看到遮罩层的背景色
- 之后吧封面图片定位在上方即可

```html
// wxml
<view class="musiclist-container" style="background:url({{listInfo.coverImgUrl}}) no-repeat"></view>
<view class="detail-mask"></view>

// wxss
.musiclist-container {
  height: 320rpx;
  filter: blur(40rpx);
  opacity: 0.4;
  
}

/*遮罩层*/
.detail-mask {
  position: absolute;
  left: 0;
  top: 0;
  z-index: -1;
  height: 320rpx;
  width: 100%;
  background-color: #333;
}

```

## 4.3绘制歌曲详情页

- wxss
- 定义了一个遮罩层在最底部。设置一个容器背景图片为当前歌曲封面并设置高斯模糊。这两个容器都是覆盖整个页面的
- 上方指针动画是一张图片使用伪元素定位到上方的。当点击播放去除一个play 类。可以实现动画

```html
<view class="player-container" style="background:url({{picUrl}}) center/cover no-repeat"></view>
<view class="player-mask"></view>

<view class="player-info">
  <view class="player-disc {{isPlaying ? 'play' : ''}}">
    <image class="playerimg rotation {{isPlaying? '' : 'pauseRotate'}}" src="{{picUrl}}"></image>
  </view>
</view>
<view class="control">
  <text class="iconfont icon-shangyishoushangyige" bindtap="onPrev"></text>
  <text class="iconfont {{isPlaying ? 'icon-zanting1' : 'icon-bofang1'}}" bind:tap="togglePlaying"></text>
  <text class="iconfont icon-xiayigexiayishou" bindtap="onNext"></text>
</view>
```

```css
/* pages/player/player.wxss */

.player-container {
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  background: center;
  filter: blur(40rpx);
  opacity: 0.4;
  z-index: -1;
}

.player-mask {
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  right: 0;
  z-index: -2;
  background-color: #222;
}

.player-info {
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  text-align: center;
}

.player-disc {
  width: 592rpx;
  height: 592rpx;
  background: url(https://s3.music.126.net/mobile-new/img/disc.png?d3bdd1080a72129346aa0b4b4964b75f=) no-repeat center/contain;
  position: absolute;
  left: 50%;
  transform: translate(-50%, 140rpx);
  /* top: 50%; */
}

.player-disc::after {
  content: '';
  position: absolute;
  width: 192rpx;
  height: 192rpx;
  left: 266rpx;
  top: -144rpx;
  background: url(https://s3.music.126.net/m/s/img/needle.png?702cf6d95f29e2e594f53a3caab50e12) no-repeat center/contain;
  transform: rotate(-15deg);
  transform-origin: 24rpx 10rpx;
  transition: all 0.5s ease;
} 

.play.player-disc::after {
  transform: rotate(5deg);
}

.playerimg {
  width: 368rpx;
  height: 368rpx;
  border-radius: 50%;
  position: absolute;
  left: 50%;
  top: 50%;
  margin-top: -184rpx;
  margin-left: -184rpx;
  /* transform: translate(-50%, -50%); */
  /* transform: translate(30%,30%); */
}

/* 播放控件部分 */

.control {
  position: absolute;
  left: 50%;
  bottom: 8%;
  transform: translate(-50%);
  display: flex;
  align-items: center;
}

.control .iconfont {
  color: #e2e2e2;
}

.icon-shangyishoushangyige, .icon-xiayigexiayishou {
  font-size: 80rpx;
}

.icon-bofang1, .icon-zanting1 {
  font-size: 100rpx;
  margin: 0 28rpx;
}

.rotation {
    -moz-animation: rotation infinite linear 12s;
    -o-animation: rotation infinite linear 12s;
    -webkit-animation: rotation infinite linear 12s;
    animation: rotation infinite linear 12s ;
}

.pauseRotate {
  animation-play-state: paused;
}

@keyframes rotation {
  0% {
    transform: rotate(0deg)
  }
  100% {
    transform: rotate(360deg)
  }
}
```

## 4.4调用小程序音乐管理的api

- wx.getBackgroundAudioManager() 是小程序获取**全局唯一**的背景音频管理器
- <https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/wx.getBackgroundAudioManager.html>官方文档

```javascript
// pages/player/player.js
// 当数据不用于展示时最好不定义在data中
let musiclist = []
// 当前正在播放歌曲的index
let nowPlayingIndex = 0
// 获取全局唯一的背景音频管理器
const backgroundAudioManager = wx.getBackgroundAudioManager()
Page({

  /**
   * 页面的初始数据
   */
  data: {
    picUrl: '',
    isPlaying: false
  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function(options) {
    console.log(options, '@@')
    nowPlayingIndex = options.index
    // 获取本地存储的数据
    musiclist = wx.getStorageSync('musiclist')
    this._loadMusicDetail(options.musicId)
  },
  // 切换播放与暂停状态
  togglePlaying() {
    console.log(this.data.isPlaying, '点击')
    if (this.data.isPlaying) {
      backgroundAudioManager.pause()
    } else {
      backgroundAudioManager.play()
    }
    this.setData({
      isPlaying: !this.data.isPlaying
    })
  },
  // 上一首
  onPrev() {
    nowPlayingIndex--
    // 说明是第一首
    if (nowPlayingIndex < 0) {
      // 那么跳到最后一首
      nowPlayingIndex = musiclist.length - 1
      this._loadMusicDetail(musiclist[nowPlayingIndex].id)
    } else {
      this._loadMusicDetail(musiclist[nowPlayingIndex].id)
    }
  },
  // 下一首
  onNext() {
    nowPlayingIndex++
    let musicListLen = musiclist.length
    // 因为nowPlayingIndex是从0开始，加1后才会和长度匹配
    if (nowPlayingIndex === musicListLen) {
      nowPlayingIndex = 0
      this._loadMusicDetail(musiclist[nowPlayingIndex].id)
    } else {
      this._loadMusicDetail(musiclist[nowPlayingIndex].id)
    }
  },
  // 加载歌曲的回调
  _loadMusicDetail(musicId) {
    // 加载下一首之前先停止上一首
    backgroundAudioManager.stop()
    wx.showLoading({
      title: '歌曲加载中~',
    })
    let music = musiclist[nowPlayingIndex]
    wx.setNavigationBarTitle({
      title: music.name,
    })
    this.setData({
      picUrl: music.al.picUrl
    })

    wx.cloud.callFunction({
      name: 'music',
      data: {
        $url: 'musicUrl',
        musicId
      }
    }).then(res => {
      console.log(res, '歌曲信息')
      let result = res.result.data[0]
      // 底部歌曲工具栏展示的信息
      backgroundAudioManager.src = result.url
      backgroundAudioManager.title = music.name
      backgroundAudioManager.coverImgUrl = music.al.picUrl
      backgroundAudioManager.singer = music.ar[0].name
      backgroundAudioManager.epname = music.al.name
      // 设置播放状态为true
      this.setData({
        isPlaying: true
      })
      wx.hideLoading()
    }).catch(err => {
      console.log(err, 'err')
    })

    console.log(music, '???')
  }
})
```

## 4.5如何在小程序中获取某个元素的属性

- 如果在页面中则为wx.createSelectorQuery()
- 如果在组件中则为this.createSelectorQuery()

```javascript
      // wx.createSelectorQuery()
      const query = this.createSelectorQuery()
      query.select('.movable-area').boundingClientRect()
      query.select('.movable-view').boundingClientRect()
      query.exec((rect) => {
        movableAreaWidth = rect[0].width
        movableViewWidth = rect[1].width
        console.log(rect, 'rect')
      })
```

## 4.6小程序中操作进度条的事件(及获取音乐长度)

- const getBackgroundAudioManager = wx.getBackgroundAudioManager()
- 获取了获取**全局唯一**的背景音频管理器
- <https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/wx.getBackgroundAudioManager.html>官方文档
- 一般在onCanplay也就是音乐进入播放状态时触发。当你切换下一首时也会触发，获取管理器的duration，得到的是当前音乐的时长（秒）
- 对数据进行处理转化为 00:00的形式展示

```javascript
// components/progress-bar/progress-bar.js
// 把获取到的move部分宽度存储起来
let movableAreaWidth = 0
let movableViewWidth = 0
let currSec = 0
let duration = 0
// 判断当前是否正在移动
let isMoving = false
const getBackgroundAudioManager = wx.getBackgroundAudioManager()
Component({
  /**
   * 组件的属性列表
   */
  properties: {

  },

  /**
   * 组件的初始数据
   */
  data: {
    showTime: {
      currentTime: '00:00',
      totalTime: '00:00',
      // movable-view x移动的距离
      movableDis: 0,
      progress: 0, // 进度条移动距离
    }
  },
  lifetimes: {
    ready() {
      this._getMovableDis()
      this._bindBGMEvent()
    },
  },
  /**
   * 组件的方法列表
   */
  methods: {
    // 监听拖动movable-view的事件
    onChange(event) {
      // 当鼠标拖动时 source为 touch，正常播放是setData操作，source为空串
      if (event.detail.source == 'touch') {
        // 设置x的距离，但不会影响页面
        this.data.movableDis = event.detail.x
        this.data.progress = event.detail.x / (movableAreaWidth - movableViewWidth) * 100
        isMoving = true
      }
    },
    // 监听鼠标抬起的事件
    toucheEnd() {
      // 获取总时间，然后根据进度条的百分比算出当前时间
      let pencentTime = this.data.progress / 100 * getBackgroundAudioManager.duration
      // 格式化时间
      let nowTime = this._dateFormat(pencentTime)
      // 只有当鼠标抬起才真正的改变页面
      this.setData({
        movableDis: this.data.movableDis,
        progress: this.data.progress,
        ['showTime.currentTime']: `${nowTime.min}:${nowTime.sec}`
      })
      // 调用api把音乐播放进度调整到计算出的当前时间
      getBackgroundAudioManager.seek(pencentTime)
    },
    // 获取可移动区域的宽度
    _getMovableDis() {
      // wx.createSelectorQuery()
      const query = this.createSelectorQuery()
      query.select('.movable-area').boundingClientRect()
      query.select('.movable-view').boundingClientRect()
      query.exec((rect) => {
        movableAreaWidth = rect[0].width
        movableViewWidth = rect[1].width
        console.log(rect, 'rect')
      })
    },
    // 操作进度条的事件
    _bindBGMEvent() {
      //监听背景音频播放事件
      getBackgroundAudioManager.onPlay(() => {
        isMoving = false
        console.log('onPlay ')
      })
      // 监听背景音频停止事件
      getBackgroundAudioManager.onStop(() => {
        console.log('onStop ')
      })
      // 监听背景音频暂停事件
      getBackgroundAudioManager.onPause(() => {
        console.log('onPause ')
      })
      //监听音频加载中事件。当音频因为数据不足，需要停下来加载时会触发
      getBackgroundAudioManager.onWaiting(() => {
        console.log('onWaiting ')
      })
      // 监听背景音频进入可播放状态事件。 但不保证后面可以流畅播放
      getBackgroundAudioManager.onCanplay(() => {
        console.log(getBackgroundAudioManager.duration, 'onCanplay ')
        if (typeof getBackgroundAudioManager.duration !== 'undefined') {
          this._setTime()
        } else {
          setTimeout(() => {
            this._setTime()
          }, 1000)
        }
      })
      // 监听背景音频播放进度更新事件，只有小程序在前台时会回调
      getBackgroundAudioManager.onTimeUpdate(() => {
        // 只有没在移动的时候才可以设置值，不然在移动的时候会冲突造成圆点跳动
        if (!isMoving) {
          const currentTime = getBackgroundAudioManager.currentTime
          const duration = getBackgroundAudioManager.duration
          // 格式化时间
          let formatTime = this._dateFormat(currentTime)
          // 判断如果是同一秒内执行多次则取消执行，以便提高性能
          if (currentTime.toString().split('.')[0] !== currSec) {
            this.setData({
              ['showTime.currentTime']: `${formatTime.min}:${formatTime.sec}`,
              movableDis: (movableAreaWidth - movableViewWidth) * currentTime / duration,
              progress: currentTime / duration * 100

            })
            currSec = currentTime.toString().split('.')[0]
            // console.log(currentTime,'onTimeUpdate')
          }
        }

      })
      // 监听背景音频自然播放结束事件


      getBackgroundAudioManager.onEnded(() => {
        this.triggerEvent('musicEnd')
        console.log('onEnded ')
      })
      // 监听背景音频播放错误事件
      getBackgroundAudioManager.onError((res) => {
        console.err(res.errMsg)
        console.log(res.errCode, 'onError')
        wx.showToast({
          title: '错误:' + res.errCode,
        })
      })
    },
    // 获取duration(当前音频的长度)
    _setTime() {
      duration = getBackgroundAudioManager.duration
      const formatTime = this._dateFormat(duration)
      this.setData({
        ['showTime.totalTime']: `${formatTime.min}:${formatTime.sec}`
      })
      console.log(formatTime, 'settime')
    },
    // 格式化时间
    _dateFormat(time) {
      // 获取分钟
      const min = Math.floor(time / 60)
      // 获取秒
      const sec = Math.floor(time % 60)
      return {
        'min': this._parse0(min),
        'sec': this._parse0(sec)
      }
    },
    _parse0(sec) {
      return sec < 10 ? '0' + sec : sec
    }
  }
})
```

## 4.7解决在播放时拖动进度条会闪的bug

- 设置一个状态位isMoving
- 默认为false，当你触发onChange，也就是拖动movable-view时状态位变为true，代表正在拖动
- 如果状态位为true那么监听音乐进度更新的事件getBackgroundAudioManager.onTimeUpdate(()里面的内容就不应该执行。
- 当你触发了onPlay事件时，说明重新播放了视频也就是拖动结束，此时才可以触发更新事件

```javascript
  // 只有组件内部才有的参数，是声明周期，ready是页面准备好    
  lifetimes: {
    ready() {
      this._getMovableDis()
      this._bindBGMEvent()
    },
  },
      
      getBackgroundAudioManager.onPlay(() => {
        isMoving = false
        console.log('onPlay ')
      })
```

## 4.8歌词组件数据的解析

- 使用组件内部的observers监听获取到歌词数据并触发下面的函数

- 运用正则匹配出时间部分，并切出对应的时分秒

- 剩下的部分为歌词，都取出后遍历放入一个数组中用于展示

  ```javascript
      _parseLyric(sLyric) {
        // 通过换行符分割为数组
        let line = sLyric.split("\n")
        // 定义一个数组存储格式化后的歌曲信息
        let _lrcList = []
        line.forEach((item) => {
          // 获取前面的时间部分
          let time = item.match(/\[(\d{2,}):(\d{2})(?:\.(\d{2,3}))]/g)
          if (time !== null) {
            // 获取时间后面的歌词部分
            let lrc = item.split(time)[1]
            // 获取小时，分钟，秒
            let timeReg = time[0].match(/(\d{2}):(\d{2})(?:\.(\d{2,3})?)/)
            let time2Seconds = parseInt(timeReg[1]) * 60 + parseInt(timeReg[2]) * 1 +
              parseInt(timeReg[3]) / 1000
            _lrcList.push({
              lrc,
              time: time2Seconds
            })
            // console.log(_lrcList, 'lrc')
          }
          console.log(time, 'time')
        })
        this.setData({
          lrcList: _lrcList
        })
        // console.log(line,'line')
      }
  ```


## 4.8根据播放进度高亮对应歌词

- 首先从进度条组件获取当前播放到的事件

- 内部把这个时间传出去

  ```javascript
              this.triggerEvent("timeUpdate", {
                currentTime
              })
  ```

- 外部也就是播放详情页接收到后再传给子组件  歌词组件

- 直接使用小程序的api   selectComponent 获取歌词组件并调用内部的方法upDate

  ```
    timeUpdate(event) {
      // console.log(event,'??')
      // 通过selectComponent获取子组件实例，调用内部方法传入数据
      this.selectComponent('.lyric').upDate(event.detail.currentTime)
    },
  ```

- 歌词组件内部定义update方法

- 接受了这个参数，并与事件列表一一对应，如果当前在播放第5s，遍历数组，如果某一项歌词对应的事件比这个时间大，说明正好对应这个歌词的上一个歌词，那么循环终止，把上一个歌词的对应序号传给页面，页面遍历找到对应序号的歌词并高亮

  ```javascript
      upDate(currentTime) {
        console.log(currentTime, 'update')
        let lrclist = this.data.lrcList
        // 如果没有歌词
        if (lrclist.length < 1) return
        for (let i = 0; i < lrclist.length; i++) {
          if (currentTime <= lrclist[i].time) {
            this.setData({
              currentLyric: i - 1,
              scrollTop: this.data.currentItemHeight * i
            })
            // 找到了则终止循环
            break
          }
        }
      }
  ```


## 4.9根据播放进度滚动歌词

- 在组件内的生命周期中，实用小程序的api获取设备信息。计算出对应这个设备的rpx比例，乘上每一项歌词的高度。可得在这个设备中，每一项歌词的高度

  ```
    lifetimes: {
      ready() {
        let Info  =wx.getSystemInfoSync()
        console.log(Info,'info')
        // 获取当前屏幕对应的rpx比例 (屏幕宽度/750)
        // 之后用这个比例乘上之前定义的rpx高度，可得对应的每一行歌词的px高度
        // 方便判断时间时改变scrollTop (scrollTop只接受px单位)
        let currentHeight = Info.windowWidth / 750 * 64
        this.setData({
          currentItemHeight: currentHeight
        })
      }
    },
  ```

- 之后在高亮歌词的同时，滚动scroll-view .  这依赖了他的属性scrollTop

  ```
      // 也是判断当前播放时间与歌词列表时间是否对应，以便高亮当前歌词的方法
      upDate(currentTime) {
        console.log(currentTime, 'update')
        let lrclist = this.data.lrcList
        // 如果没有歌词
        if (lrclist.length < 1) return
        for (let i = 0; i < lrclist.length; i++) {
          if (currentTime <= lrclist[i].time) {
            this.setData({
              currentLyric: i - 1,
              scrollTop: this.data.currentItemHeight * i
            })
            // 找到了则终止循环
            break
          }
        }
      }
  ```


## 4.10当当前播放部分对应没有歌词时的处理

```
      // 如果当前播放的部分没有对应歌词，那么会移动到最底部并不会高亮
      // 如果最后一项有时间，不为空
      if (this.data.setFlag && lrclist[lrclist.length - 1] && currentTime > lrclist[lrclist.length - 1].time) {
        console.log('进入1')
        this.setData({
          currentLyric: -1,
          scrollTop: this.data.currentItemHeight * lrclist.length,
          setFlag: false
        })
      }
```

## 4.11musiclist组件根据播放的歌曲动态高亮

- 在app.js中设定全局变量
- 当player.js中的加载歌曲回调触发时设置 音乐id，当musiclist音乐列表组件被显示的时候，在其组件-页面生命周期中获取当前全局的音乐id并赋值给内部
- 注意要使用全局的变量或者方法
- 必须先 const App = getApp ()
- 之后就可以 app.全局方法名

```
    this.globalData = {
      // 设定全局的musicId,也就是正在播放的id
      playingMusicId: -1
    }
  },
  // 设定全局id的方法
  setPlayMusicId(musicId) {
    this.globalData.playingMusicId = musicId
  },
  // 获取全局id的方法
  getPlayMusicId() {
    return this.globalData.playingMusicId
  }
```

## 4.12点击同一首歌曲不会重新播放

- 获取全局的musicId判断与当前播放音乐的 id是否相同

- 如果相同那么不初始化音乐播放

  ```javascript
      wx.cloud.callFunction({
        name: 'music',
        data: {
          $url: 'musicUrl',
          musicId
        }
      }).then(res => {
        console.log(res, '歌曲信息')
        let result = res.result.data[0]
        // 当前歌曲是vip专属，无法播放
        if (result.url == null) {
          wx.showToast({
            title: '无权限播放',
          })
          return
        }
        // 底部歌曲工具栏展示的信息
        if (!this.data.isSame) {
          // 设定这些信息会重新加载
          backgroundAudioManager.src = result.url
          backgroundAudioManager.title = music.name
          backgroundAudioManager.coverImgUrl = music.al.picUrl
          backgroundAudioManager.singer = music.ar[0].name
          backgroundAudioManager.epname = music.al.name
        }
        // 设置播放状态为true
          this.setData({
            isPlaying: true
          })
        // 获取当前歌曲的歌词
        wx.cloud.callFunction({
          name: 'music',
          data: {
            $url: 'lyric',
            musicId
          }
        }).then(res => {
          // let lyr = JSON.parse(res.result).lrc.lyric
          let lyr = JSON.parse(res.result).lrc
          // console.log(lyr,'要给的')
          if (lyr.lyric) {
            // 获取歌词并赋值
            this.setData({
              lyric: lyr.lyric
            })
          } else {
            this.setData({
              lyric: '暂无歌词'
            })
          }
        })
        wx.hideLoading()
      }).catch(err => {
        console.log(err, 'err')
      })
  ```

  ## 4.13点击底部控件同时操作播放按钮

  - progress.js 中监听控件的暂停和开始事件。调用父组件的方法。动态更改播放状态

    ```
          getBackgroundAudioManager.onPlay(() => {
            this.triggerEvent('onPlay')
            isMoving = false
            console.log('onPlay ')
          })
          // 监听背景音频停止事件
          getBackgroundAudioManager.onStop(() => {
            console.log('onStop ')
          })
          // 监听背景音频暂停事件
          getBackgroundAudioManager.onPause(() => {
            console.log('onPause ')
            this.triggerEvent('onPause')
          })
    ```

  - 父组件player.js

    ```
      onPlay() {
        this.setData({
          isPlaying: true
        })
      },
      onPause() {
        this.setData({
          isPlaying: false
        })
      },
    ```

# 5.0发现页面制作

## 5.1发现页面头部布局

- blog.wxml定义布局

  ```html
  <view class="container">
    <!-- 头部部分 -->
    <view class="header">
      <view class="publish-container">
        <i class="iconfont icon-fabu" />
      </view>
      <view class="search-container">
        <x-search iconfont="iconfont" icon-sousuo="icon-sousuo" />
      </view>
    </view>
  </view>
  ```

- 定义blog.wxss样式

  ```css
  /* pages/blog/blog.wxss */
  .container {}
  /* 头部部分 */
  .header {
    display: flex;
    height: 100rpx;
    align-items: center;
    background-color: #fff;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    border:1px solid red;
    z-index: 99;
    width: 100%;
    padding: 0 20rpx;
    box-sizing: border-box;
  }
  
  .search-container {
    flex: 1;
    /* border: 1px solid blue; */
  }
  
  .publish-container {
    width: 68rpx;
    height: 68rpx;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  .publish-container > .icon-fabu {
    font-size: 48rpx;
  }
  ```


## 5.2搜索框组件布局

- search 组件

  ```
  <view class="container">
    <i class="iconfont icon-sousuo search-icon" />
    <input class="bar input-plc" placeholder="{{placeholder}}"></input>
    <button class="search" size="mini">搜索</button>
  </view>
  ```

- search 组件样式

  ```css
  /* components/search/search.wxss */
  
  .container {
    width: 100%;
    position: relative;
    /* margin-left: 20rpx; */
    display: flex;
    align-items: center;
  }
  
  .search-icon {
  width: 55rpx;
  height: 55rpx;
  position: absolute;
  left: 22rpx;
  top: 19rpx;
  
  }
  
  .bar {
    flex: 1;
    /* width: 100%; */
    /* flex-grow: 1; */
    background-color: #f5f5f5;
    height: 68rpx;
    border-radius: 20rpx;
    padding-left: 68rpx;
  }
  
  .search {
    background-color: #d43c33;
    color: #fff;
    font-size: 24rpx;
    margin-left: 20rpx;
  }
  
  .container > .search {
    padding: 0 1.5em;
    border-radius: 16rpx;
  }
  
  .input-plc {
    color: #999;
  }
  
  ```

- 使用外部样式

  ```
  因为组建内部无法获取全局的app.css样式
  因此使用组建内部的
    externalClasses:[
      "iconfont",
      "icon-sousuo"
    ],
  方法来获取样式
  父组件      <x-search iconfont="iconfont" icon-sousuo="icon-sousuo" />
  传入对应的样式，子组件即可获取并使用
  但是只能使用无法修改，如果有其他需求可以自己定义一个class类来操作
  ```

## 5.3组件内部使用组建外部样式的三种方法总结

1. 组件外部通过在标签上写入样式名称的方式，组建内部使用externalClasses接收样式

   ```
     externalClasses:[
       "iconfont",
       "icon-sousuo"
     ],
   ```

2. 直接把样式拷贝进组件的目录中即可使用

3. 组建内部定义属性，即可与父组件互通并修改样式 （不推荐）

   ```
     options: {
       styleIsolation: 'apply-shared'
     },
   ```

## 5.4用户信息授权与获取

1. 当点击某个需要权限的按钮时，调用方法 wx.getSetting ,如果返回对象中scope.userInfo为true，代表当前用户已经授权

   ```javascript
       // 判断用户是否授权
       wx.getSetting({
         success:(res)=> {
           console.log(res, '授权')
           // 说明授权了
           if (res.authSetting['scope.userInfo']) {
             wx.getUserInfo({
               success: (res) => {
                 console.log(res, '获取用户西悉尼')
               }
             })
           }
           //用户未授权
           else {
             this.setData({
               showModal: true
             })
           }
         }
       })
   ```

2. 如果当前用户为授权，就打开自定义的授权弹窗并调用api ,如果成功获取到可以在对象的detail中获取到用户的信息

   ```
   <button class="login" open-type="getUserInfo" bindgetuserinfo="handleGetUserInfo">获取微信授权信息</button>
   
   
     methods: {
       handleGetUserInfo(event) {
         console.log(event,'信息啊啊')
       }
     }
   ```

   {nickName: "Pluto", avatarUrl: "https://wx.qlogo.cn/mmopen/vi_32/F09h1iby0Ot2dns0P…HEs2ibvl9ib7ia0VyFCZ3MGfoYXfckZ4lMffV5GcXFJ5Q/132"} "blog-edit接受数据"

## 5.5发布页面的制作

- 原生组件textarea绑定 input事件必须 是bindInput连写，不能用 ：分割

- 底部控件可以使用css样式控制，当textarea获取焦点时，说明用户要输入内容，此时调用 bindfocus 对应的方法，事件对象的detail中包含了用户输入框的高度，此时把这个高度赋给 底部控件的top值，当失去焦点重新设为0即可

  ```
    },
    // 文本域获取焦点事件，可获取输入栏的高度,注意只在真机有效
    onFocus(event) {
      this.setData({
        footerBottom: event.detail.height
      })
    },
    // 文本域失去焦点事件
    onBlur() {
      this.setData({
        footerBottom: 0
      })
    },
  ```


## 5.6用户上传图片功能

- 点击上传图片的区域时，调用小程序api

  ```javascript
    // 选择图片的函数
    chooseImg() {
      wx.chooseImage({
        count: MAX_IMAGE_NUM - this.data.images.length, //最多可选择几张
        sourceType: ['album', 'camera'], // 图片来源
        sizeType: ['original', 'compressed'], // 所选的图片的尺寸
        success: (res) => {
          // console.log(res.tempFilePaths)
          this.setData({
            images: this.data.images.concat(res.tempFilePaths)
          })
        },
      })
    },
  ```


## 5.7图片的删除功能

- 给图片右上角定位的删除图标绑定事件，并设置data-index传入当前点击图片的序号

- 使用splice方法修改原有数组并setData即可

  ```javascript
    // 删除图片的回调
    onDelImage(event) {
      let images = this.data.images
      images.splice(event.currentTarget.dataset.index,1)
      this.setData({
        images: images,
        selectphoto:this.data.images.length >= 9 ? true : false,
      })
    },
  ```


## 5.8图片的预览功能

- 图片绑定点击事件
- 注意在模拟器中有时无法退出预览，但真机无问题

```
  // 预览图片
  previewImg(event) {
    let src = this.data.images[event.currentTarget.dataset.index]
    wx.previewImage({
      current: src, // 当前显示图片的http链接
      urls: this.data.images // 需要预览的图片http链接列表
    })
  },
```

## 5.9把图片上传到云存储

- 调用云存储的api  wx.cloud.uploadFile,这个api一次只能上传一个文件或者图片，因此上传多个需要循环上传	 

- 注意参数cloudPath 是上传到云端的路径，前面加上 例如 blog/则代表上传到云存储中 blog文件夹下

- filePath是要上传内容的本地存储李静

  ```javascript
    // 上传图片至云存储的函数
    send() {
      for (let i = 0; i < this.data.images.length; i++) {
        let item = this.data.images[i]
        // 正则匹配拓展名
        let suffix = /[^\.]\w*$/.exec(item)[0]
        wx.cloud.uploadFile({
          // 上传至云端的路径
          cloudPath: 'blog/' + Date.now() + '-' + Math.random() + 1000000 + suffix,
          filePath: item,
          success: (res) => {
            console.log(res, '成功')
          },
          fail: (err) => {
            console.log(err, '失败')
  
          }
        })
      }
    },
  ```


## 5.10把发布的内容上传到云数据库

- 把用户的输入内容存储起来，每次图片上传云存储成功的回调把fileId存入一个数组

- 定义当前时间为服务端时间 createTime: db.serverDate()

- 把该页面接收到的参数存储起来

- 使用Promise.all  把之前的每个上传请求封装为promise对象。注意要resolve任意的东西，如果promise.all成功了，在这个回调中上传云存储并加入loading弹窗，因为上传一般较慢

  ```javascript
    // 上传图片至云存储的函数
    send() {
      if (content.trim() === '') {
        wx.showModal({
          title: '请输入内容',
          content: '',
        })
        return
      }
      wx.showLoading({
        title: '正在上传~',
      })
      // 定义一个存放promise的数组
      let promiseArr = []
      // 存放fileId的数组
      let fileIds = []
      for (let i = 0; i < this.data.images.length; i++) {
        let item = this.data.images[i]
        // 正则匹配拓展名
        let suffix = /[^\.]\w*$/.exec(item)[0]
        let p = new Promise((resolve, reject) => {
          wx.cloud.uploadFile({
            // 上传至云端的路径
            cloudPath: 'blog/' + Date.now() + '-' + Math.random() + 1000000 + '.' + suffix,
            filePath: item,
            success: (res) => {
              console.log(res, '成功')
              fileIds = fileIds.concat(res.fileID)
              resolve(res.fileID)
            },
            fail: (err) => {
              console.log(err, '失败')
              reject()
            }
          })
        })
        promiseArr.push(p)
      }
      // 利用promise.all 当执行回调说明所有图片都成功上传
      Promise.all(promiseArr).then(res => {
        console.log(res, 'all')
        db.collection('blog').add({
          data: {
            content,
            img: fileIds,
            createTime: db.serverDate(), // 应该以服务端时间为准
            ...userInfo
          }
        }).then(res => {
          wx.showToast({
            title: '发布成功!',
          })
          wx.hideLoading()
        }).catch(err => {
          console.err(err)
          wx.hideLoading()
        })
      }).catch(err => {
        wx.hideLoading()
        wx.showToast({
          title: '发布失败,请稍后再试',
          icon: 'none'
        })
      })
    },
  ```


## 5.11使用云函数获取云数据的发布信息

1. 定义云函数，新建云函数blog，代表与发布相关的云函数全在这里

   ```javascript
   // 云函数入口文件
   const cloud = require('wx-server-sdk')
   
   const TcbRouter = require('tcb-router')
   
   
   cloud.init()
   
   const blogCollection = cloud.database().collection('blog')
   // 云函数入口函数
   exports.main = async(event, context) => {
     const app = new TcbRouter({
       event
     })
     // 获取blog数据库数据的云函数
     app.router('list', async(ctx, next) => {
       // 获取数据库数据,并按时间倒叙排列
       console.log(event, 'event')
       ctx.body = await blogCollection.skip(event.start).limit(event.count).orderBy('createTime', 'desc').get().then(res => {
         return res.data
       })
     })
     return app.serve()
   }
   ```

2. 调用云函数

   ```javascript
     //  获取云数据库中博客的数据
     _loadBlogList() {
       wx.cloud.callFunction({
         name: 'blog',
           // 云函数需要的参数
         data: {
           start: 0,
           count: 10,
           $url: 'list'
         }
       }).then(res => {
         this.setData({
           blogList: this.data.blogList.concat(res.result)
         })
         console.log(res, '获取云函数')
       })
     },
     /**
      * 生命周期函数--监听页面加载
      */
     onLoad: function(options) {
       console.log('onload')
       this._loadBlogList()
     },
   ```

## 5.12发现列表展示卡片开发

- 构建卡片的基本结构和样式，为文字一栏，内容一栏。图片一栏  blog-card.wxml

  ```html
  <view class="blog">
    <!-- 个人信息部分 -->
    <view class="title">
      <view class="userImg">
        <image src="{{blog.avatarUrl}}" lazy-load mode="widthFix"></image>
        <!-- <image mode="widthFix" src="{{blog.avatarUrl}}></image> -->
      </view>
      <view class="userInfo">
        <view class="userInfo-name">{{blog.nickName}}</view>
        <view class="userInfo-time">{{_createTime}}</view>
      </view>
    </view>
    <!-- 内容部分 -->
    <view class="content">
      {{blog.content}}
    </view>
    <!-- 图片列表部分 -->
    <view class="imgList">
      <block wx:for="{{blog.img}}" wx:key="*this">
        <image class="imgItem" mode="aspectFill" lazy-load src="{{item}}"></image>
      </block>
    </view>
  </view>
  ```

- js部分

  ```javascript
  // components/blog-card/blog-card.js
  const formatTime = require("../../utils/formatTime.js")
  Component({
    /**
     * 组件的属性列表
     */
    properties: {
      blog: {
        type: Object,
        value: {}
      }
    },
    observers: {
      ['blog.createTime'](val) {
        // 格式化时间
        let fmtTime = formatTime(new Date(val))
        this.setData({
          _createTime: fmtTime
        })
      }
    },
    /**
     * 组件的初始数据
     */
    data: { 
      _createTime: ''
    },
  
    /**
     * 组件的方法列表
     */
    methods: {
  
    }
  })
  ```


## 5.13定义格式化时间的函数

- 把时间格式化为  'yyyy-MM-dd hh:mm:ss'的形式

- 如果有需求为其他形式，只需要更改 fmt 的格式即可

- 例如需要 yyy-MM-dd 只需把后面的删除即可

- 这个函数需要的参数需要是 new Date（服务段时间）的返回值

  ```javascript
  module.exports = (date) => {
    let fmt = 'yyyy-MM-dd hh:mm:ss'
    const o = {
      'M+':date.getMonth() + 1, // 获取月份，注意只能获取0-11 因此加1对应正确月份
      'd+':date.getDate(), // 日
      'h+':date.getHours(), // 小时
      'm+':date.getMinutes(), // 分钟
      's+':date.getSeconds() // 秒
    }
    // 正则匹配，如果匹配到年份就替换 yyyy为年份
    // $1代表匹配到的第一项
    if (/(y+)/.test(fmt)) {
      fmt = fmt.replace(RegExp.$1,date.getFullYear())
    }
  
    for(let k in o) {
      // 循环o对象，如果匹配到了规则，例如M+
      if (new RegExp('('+k+')').test(fmt)) {
        console.log(o[k].toString().length,'o[k].toString().length')
        // 匹配到则替换，并判断例如 date.getDate()的长度是否为1
        // fmt = fmt.replace(RegExp.$1,o[k].toString().length == 1 ? '0' + o[k] : o[k])
        fmt = fmt.replace(RegExp.$1,o[k].toString().length == 1 ? '0' + o[k] : o[k])
      }
    }
    // console.log(fmt)
    return fmt
  }
  ```

## 5.14发布新卡片后返回发布页面并刷新

- 发布页面的刷新就相当于下拉刷新，因此在发布成功后调用发布页面的下拉刷新即可

- 使用 getCurrentPages() api 注意没有wx.  即可获得最近的页面

  ```javascript
      // 利用promise.all 当执行回调说明所有图片都成功上传
      Promise.all(promiseArr).then(res => {
        console.log(res, 'all')
        db.collection('blog').add({
          data: {
            content,
            img: fileIds,
            createTime: db.serverDate(), // 应该以服务端时间为准
            ...userInfo
          }
        }).then(res => {
          wx.showToast({
            title: '发布成功!',
            duration: 1000,
            success: () => {
              setTimeout(() => {
                let page = getCurrentPages()
                let prevPage = page[page.length - 2]
                prevPage.onPullDownRefresh()
                wx.navigateBack()
              }, 1000)
              console.log(page, 'pae')
            }
          })
          wx.hideLoading()
        }).catch(err => {
          console.log(err)
          wx.hideLoading()
        })
      }).catch(err => {
        wx.hideLoading()
        wx.showToast({
          title: '发布失败,请稍后再试',
          icon: 'none'
        })
      })
  ```


## 5.15发布页面模糊查询功能

- 搜索组件返回用户输入的内容

- 调用云函数并把关键字传入，把页面的数据置空，调用加载数据的方法

  ```javascript
    //  获取云数据库中博客的数据
    _loadBlogList(start = 0, keyWord = '') {
      wx.showLoading({
        title: '加载中',
      })
      wx.cloud.callFunction({
        name: 'blog',
        data: {
          start,
          count: 10,
          keyWord,
          $url: 'list'
        }
      }).then(res => {
        this.setData({
          blogList: this.data.blogList.concat(res.result)
        })
        if (res.result.length == 0) {
          wx.showToast({
            title: '没有更多了~',
            icon: 'none'
          })
        }
        wx.hideLoading()
        wx.stopPullDownRefresh()
        console.log(res, '获取云函数')
      }).catch(err => {
        wx.stopPullDownRefresh()
        wx.hideLoading()
        console.err(err)
      })
    },
  ```

- 正则匹配查询条件，这个代表你写入你的变量，云函数会动态生成正则表达式来匹配你需要查找的内容

- 这里是keyword，因此content最后会转变为一个匹配keyword变量的值的正则表达式

-         content: cloud.database().RegExp({
            regexp: keyWord,
            // 大小写不敏感
            options: 'i'
          })
  复用之前的云函数，增加一个查询条件，根据where查询符合正则条件的content项

  ```javascript
  // 云函数入口文件
  const cloud = require('wx-server-sdk')
  
  const TcbRouter = require('tcb-router')
  
  
  cloud.init()
  
  const blogCollection = cloud.database().collection('blog')
  // 云函数入口函数
  exports.main = async(event, context) => {
    const app = new TcbRouter({
      event
    })
    // 获取blog数据库数据的云函数
    app.router('list', async(ctx, next) => {
      let keyWord = event.keyWord
      // 声明一个查询条件对象
      let w = {}
      if (keyWord.trim() !== '') {
        w = {
          // 使用正则匹配关键字 db.RegExp是数据库的方法
          // https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/database/Database.RegExp.html
          content: cloud.database().RegExp({
            regexp: keyWord,
            // 大小写不敏感
            options: 'i'
          })
        }
        console.log(w, '输出w')
      }
      // 获取数据库数据,并按时间倒叙排列
      console.log(event, 'event')
      ctx.body = await blogCollection.where(w).skip(event.start).limit(event.count).orderBy('createTime', 'desc').get().then(res => {
        return res.data
      })
    })
    return app.serve()
  }
  ```


## 5.16优化云数据库查询速度（新建索引）

- 打开云开发控制台
- 找到云数据库的索引管理
- 新建检索字段的索引，当前检索的是content，因此新建索引，索引名称可以任意起名，索引字段对应要检索的字段即可
- 注意这会额外使用数据库的空间，相当于空间换时间

## 5.17小程序段和云端调用数据库的差别

- 小程序端调用数据库权限与云端不同，云端默认拥有所有读写权限，而小程序端则不可读，可以在云数据权限栏配置
- 小程序端返回的时间通常为一个对象，可能会影响之后的格式化，因此可以循环 调用 toString() 转换为字符串类型 

## 5.18评论组件开发

- 新增 blog-ctrl 组件，内部为评论分享两个按键。

- 把这个组件放到循环渲染博客卡片列表的部分和每张卡片拼接在一起

- 由于评论需要授权，因此点击评论调用 login组件，当授权成功显示评论弹窗。失败则提示

- 注意要给textarea设置 fix:true才会与弹窗一块运动   

  ```html
  <view class="ctrl">
    <view class="ctrl-item" bind:tap="onComment">
      <i class="iconfont icon-pinglun icon"></i>
      <text>评论</text>
    </view>
    <view class="ctrl-item share">
      <!-- <i class="iconfont icon-iconfontzhizuobiaozhun023130 icon"></i> -->
      <i class="iconfont icon-fenxiang" />
      <text>分享</text>
    </view>
  </view>
  
  <!-- 授权组件 -->
  <x-login showModal="{{showLogin}}" bind:onLoginSuccess="onLoginSuccess" bind:onLoginFail="onLoginFail" />
  <!-- 评论弹窗组件 -->
  <x-bottom-modal showModal="{{showBottomModal}}">
    <view slot="modal-content" class="content-container">
      <textarea class="content" placeholder="{{placeholder}}" content="{{content}}" fixed="true"></textarea>
      <button class="pubButton" size="mini">发布</button>
    </view>
  </x-bottom-modal>
  ```

  ```
  /* components/blog-ctrl/blog-ctrl.wxss */
  
  .ctrl {
    display: flex;
    align-items: center;
    height: 60rpx;
    background-color: #fff;
  }
  
  .ctrl-item {
    flex: 1;
    display: flex;
    justify-content: center;
    position: relative;
    height: 100%;
    align-items: center;
    color: rgba(40, 47, 60, 0.8);
  }
  
  .ctrl-item text {
    margin-left: 14rpx;
  }
  
  .content-container {
    position: relative;
    width: 100%;
    height: 100%;
  }
  
  .content {
    margin: 20rpx 40rpx 20rpx 20rpx;
    min-height: 200rpx;
    text-align: left;
    padding: 20rpx;
    box-sizing: border-box;
  }
  
  .pubButton {
    position: absolute;
    right: 0;
    bottom: 0;
    margin: 20rpx;
    background-color: red;
    color: #fff;
  }
  
  ```


## 5.19动态设置评论弹窗的位置，防止输入法覆盖弹窗

## 5.20一对多的关系

- 一个对应多个信息，例如一个人对应多件衣服

## 5.21发布评论功能

- 点击评论发送请求存储数据到云数据库

- 云函数Blog

  ```javascript
    // 获取评论并插入数据库的云函数
    app.router("comment", async(ctx, next) => {
      console.log(event, '输入event')
      await cloud.database().collection('blog-comment').add({
        data: {
          openId: event.userInfo.openId,
          avatarUrl: event.avatarUrl,
          blogId: event.blogId,
          createTime: cloud.database().serverDate(),
          content: event.content,
          nickName: event.nickName
        }
      }).then(res=> {
        console.log('插入成功!')
      })
      await next()
    })
  ```

- 调用函数

  ```javascript
      // 点击发布评论的回调
      publishComment() {
        wx.showLoading({
          title: '发布中~',
        })
        wx.cloud.callFunction({
          name: 'blog',
          data: {
            $url: 'comment',
            nickName: userInfo.nickName,
            blogId: this.properties.blogId,
            content: this.data.content,
            avatarUrl: userInfo.avatarUrl
          }
        }).then(res => {
          wx.showModal({
            title: '发布成功!',
          })
          this.setData({
            showBottomModal: false,
            content: ''
          })
          wx.hideLoading()
        }).catch(err => {
          console.log(err, 'err')
          wx.hideLoading()
        })
      },
  ```


## 5.22使用表单来提交数据

- 重构之前的提交评论代码  blog-ctrl.wxml

  ```html
  <!-- 评论弹窗组件 -->
  <x-bottom-modal showModal="{{showBottomModal}}">
    <!-- 模板消息推送 -->
    <form slot="modal-content" bind:submit="publishComment" report-submit="true" class="content-container">
      <!-- <textarea class="content" auto-focus bindblur="onBlur" value="{{content}}" bindfocus="onFocus" placeholder="{{placeholder}}" fixed="true"></textarea> -->
      <textarea name="content" class="content"  auto-focus bindblur="onBlur" bindfocus="onFocus" placeholder="{{placeholder}}" value="{{content}}" fixed="true"></textarea>
      <button class="pubButton" form-type="submit" size="mini">发布</button>
    </form>
  </x-bottom-modal>
  ```

- 使用form来包裹表单内容，设置   report-submit="true"  来配合按钮的 form-type="submit" 来实现提交内容

- 注意要想获取输入的值，例如textarea 则 必须给该表单组件增加一个name才可以！！。表单的bind:submit="publishComment"可以获取一个参数里面包含了表单的值

## 5.23 订阅消息推送功能（终点）

- 由于小程序更新，新api为  cloud.openapi.subscribeMessage.send

- 首先客户端绑定点击事件，触发 wx.requestSubscribeMessage 事件

- <https://developers.weixin.qq.com/miniprogram/dev/api/open-api/subscribe-message/wx.requestSubscribeMessage.html>api地址

- 需要传入你定义的模板id<https://mp.weixin.qq.com/wxamp/newtmpl/mytmpl?start=0&limit=10&token=339259184&lang=zh_CN>。按照自己的需要定义一个模板id并传入即可。（注意前提填写了小程序类目）

  ```javascript
        wx.requestSubscribeMessage({
          tmplIds: ['nKqNdwy50PHoBP1sBSH4w2nnfsSbMVtRXizdC_mXrKA'],
          success: () => {
            wx.getSetting({
              success: (res) => {
                console.log(res)
                // 说明登录了
                if (res.authSetting['scope.userInfo']) {
                  wx.getUserInfo({
                    success: (res) => {
                      userInfo = res.userInfo
                      // 显示评论弹出层
                      this.setData({
                        showBottomModal: true
                      })
                    }
                  })
                } else {
                  this.setData({
                    showLogin: true
                  })
                }
              }
            })
          },
          fail: (res) => {
            console.log(res,'输出失败')
            wx.showModal({
              title: '授权后才能继续~'
            })
          }
        })
  ```

- 云函数调用api    cloud.openapi.subscribeMessage.send

- 注意data里的参数是根据你的模板来定义的，最少有两个

  ```javascript
  // 云函数入口文件
  const cloud = require('wx-server-sdk')
  
  cloud.init()
  
  // 云函数入口函数
  exports.main = async(event, context) => {
    // 获取用户openId
    const {
      OPENID
    } = cloud.getWXContext()
    console.log(OPENID, 'OPENID')
    console.log(event, 'event')
    // 跳转到评论页面，并携带blogId
  
    // subscribeMessage.send
    const result = await cloud.openapi.subscribeMessage.send({
      touser: OPENID,
      lang: 'zh_CN',
      page: `/pages/blog-comment/blog-comment?blogId=${event.blogId}`,
      data: {
        date4: {
          value: '2020-1-1 14:00'
        },
        thing3: {
          value: '评价完成'
        }
      },
      templateId: 'nKqNdwy50PHoBP1sBSH4w2nnfsSbMVtRXizdC_mXrKA',
      miniprogramState: 'developer'
      // formId: event.formId
    })
    return result
  }
  ```

- 自己测试的结果是 wx.requestSubscribeMessage 不管同意与否，只要拉起这个询问框就可以推送。只有用户在客户端设置禁止推送才会触发失败的回调，点击取消并无效果

## 5.24根据blogId获取当前评论详情和评论列表（推送详情页）

- 在blog写入新云函数。根据blog查询当前评论和评论列表

- 注意当前评论和评论列表是两个集合

- 先查评论，因此当前评论详情只有一个

- 再查评论列表，因为评论列表可能有多个，因此查出全部并遍历出blogId匹配的评论列表项

  ```javascript
    // 获取当前blogId对应的评论和图片内容信息
    app.router('detail', async(ctx, next) => {
      let blogId = event.blogId
      // 对应blogId的详情查询
      let detail = await cloud.database().collection('blog').where({
        _id: blogId
      }).get().then(res => {
        return res.data
      })
      // 评论查询
      const countResult = await cloud.database().collection('blog-comment').count()
      const total = countResult.total
      let commentList = {
        data: []
      }
      if (total > 0) {
        // 表示要查询的次数
        const batchTimes = Math.ceil(total / MAX_LIMIT)
        const tasks = []
        for (let i = 0; i < batchTimes; i++) {
          let promise = await cloud.database().collection('blog-comment').skip(i * MAX_LIMIT).limit(MAX_LIMIT).where({
            blogId
          }).orderBy('createTime', 'desc').get()
          tasks.push(promise)
        }
        if (tasks.length > 0) {
          commentList = (await Promise.all(tasks)).reduce((acc, cur) => {
            return {
              data: acc.data.concat(cur.data)
            }
          })
        }
      }
  
      ctx.body = {
        commentList,
        detail
      }
    })
  ```

- 调用云函数

  ```javascript
    _getBlogDetail(blogId) {
      wx.showLoading({
        title: '加载中',
        mask: true
      })
      wx.cloud.callFunction({
        name: 'blog',
        data: {
          $url: 'detail',
          blogId
        }
      }).then(res=> {
        wx.hideLoading()
        console.log(res,'comment')
      })
    },
  ```


## 5.25云开发分享功能

- 要想使用分享功能，必须使用按钮，并设置open-type 为share

- 可以给按钮通过data-xxx的方式绑定分享所必须的值，例如标题，图片，携带的blogId等。（注意如果传递blogId很可能Id是小写，造成获取不到参数）

- 之后可通过分享组件所在页面的  onShareAppMessage 方法来分享

  ```javascript
    /**
     * 用户点击右上角分享
     */
    onShareAppMessage: function(event) {
      let dataset = event.target.dataset
      let realUrl = ''
      wx.cloud.getTempFileURL({
        fileList: [{
          fileID: dataset.blog.img[0],
          maxAge: 60 * 60, // one hour
        }]
      }).then(res => {
        // get temp file URL
        console.log(res.fileList)
        let realUrl = res.fileList[0].tempFileURL
      }).catch(error => {
        // handle error
      })
      console.log(realUrl, 'realUrl')
  
      return {
        title: dataset.blog.content,
        path: `/pages/blog-comment/blog-comment?blogId=${dataset.blogid}`,
        imageUrl: "https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1963028709,2899678926&fm=26&gp=0.jpg"
      }
    }
  ```


# 6.0我的页面制作

## 6.1用户信息授权的方法

1. 推荐通过定义一个按钮，设置open-type="getUserInfo" ，绑定bindgetuserinfo="getUser"，也就是绑定获取信息的函数，点击后即可拉起询问授权的弹窗

   ```
   <open-data type="userNickName"></open-data>
   <open-data type="userAvatarUrl"></open-data>
   ```

2. wx.getUserInfo()方法，可以在成功的回调里获取用户信息，但是注意，只有当前授权了才会返回值

3. 上面两种方法虽然可以获取用户信息，但是无法获取openid

4. 传统获取openId的方法   

   ```
   1.用户端小程序调用 wx.login 从获取微信服务器code
   2.用户端小程序调用 wx.request 把 code 传给后端
   3.后端用code换取openid和session_key(秘钥)
   4.用户端把openid本地存储
   ```

5. 云函数获取openid的方法，定义一个按钮绑定事件，调用云函数即可

   ```res
   wx.cloud.callFunction({
       name: 'login'
   }).then(res=>res)
   ```


## 6.2在json中配置页面不可滚动

- 在对应页面的json文件增加disableScroll即可

```
{
  "usingComponents": {
    "x-progress-bar": "../../components/progress-bar/progress-bar",
    "x-lyric": "../../components/lyric/lyric"
  },
  "disableScroll": true
}
```

## 6.3的页面搭建

- 注意如果使用了<open-data class="userAvatarUrl" type="userAvatarUrl"></open-data>这个组件，要想把图片设置为圆形需要加入以下样式

```
  <open-data class="userAvatarUrl" type="userAvatarUrl"></open-data>
  
.userAvatarUrl {
  width: 200rpx;
  height: 200rpx;
  display: block;
  overflow: hidden;
  border: 6rpx solid #fff;
  border-radius: 50%;
}
```

## 6.4播放音乐存入历史记录

- 在app.js中，每次初始化都设置一个历史记录数组

- 在每次onlanuch的时候调用一下

  ```javascript
    // 获取全局id的方法
    getPlayMusicId() {
      return this.globalData.playingMusicId
    },
    // 获取当前用户openId的方法
    getOpenid() {
      wx.cloud.callFunction({
        name: 'login'
      }).then(res => {
        console.log(res,'res')
        // 把openid存储在全局
        const openid = res.result.event.userInfo.openId
        this.globalData.openid = openid
        // 如果本地没有记录则设置一个，有则无操作
        if (wx.getStorageSync(openid) == '') {
          wx.setStorageSync(openid, [])
        }
      })
    },
  ```

- 播放音乐时，判断当前音乐是否已经存在历史记录中，不存在则加入历史记录

  ```javascript
    // 播放歌曲保存历史记录
    savePlayHistory() {
      let currentMusic = musiclist[nowPlayingIndex]
      let openId = getApp().globalData.openid
      console.log(openId,'openId')
      let historyList = wx.getStorageSync(openId)
      console.log(historyList,'historyList')
      let isSameMusic = false
      for (let i = 0; i < historyList.length; i++) {
        // 说明是同一首
        if (historyList[i].id == currentMusic.id) {
          isSameMusic = true
          break
        }
      }
      if (!isSameMusic) {
        historyList.unshift(currentMusic)
        wx.setStorageSync(openId, historyList)
      }
    },
  ```


## 6.5通过云函数获取我的页面的信息，根据openId

- 云函数

  ```
    // 获取当前OPENID对应的发现列表
    app.router('getListbyOpenId',async (ctx,next)=> {
      const { OPENID } = cloud.getWXContext()
      ctx.body = await blogCollection.where({ _openid: OPENID}).skip(event.start).limit(event.count).get().then(res=> {
        return res.data
      })
    })
  ```

- 调用云函数

  ```javascript
    // 云函数获取我的数据。根据当前用户的openId
    _getBlogHistoryList() {
      wx.showLoading({
        title: '加载中~',
      })
      wx.cloud.callFunction({
        name: 'blog',
        data: {
          $url: 'getListbyOpenId',
          start: this.data.blogList.length,
          count: MAX_LIMIT
        }
      }).then(res => {
        wx.hideLoading()
        if (res.result.length == 0) {
          wx.showToast({
            title: '我也是有底线的~',
            icon: 'none',
          })
          return
        }
        this.setData({
          blogList: this.data.blogList.concat(res.result)
        })
        console.log(res, '输出结果')
      })
    },
  ```


## 6.6从小程序段获取云数据库的我的数据

- 数据库权限默认即可，因为在这个仅创建者可读写，只能拿到自己的数据，因此无需增加where条件使用openid过滤数据

- 本地获取的代码，只是获取方法少传一个过滤条件，其他都一样

- 注意小程序端调用返回的事件格式是对象，因此toString()转为字符串才可正常显示

  ```javascript
    _getListByMiniprogram() {
      wx.showLoading({
        title: '加载中',
      })
      db.collection('blog').skip(this.data.blogList.length)
        .limit(MAX_LIMIT).orderBy('createTime', 'desc').get().then((res) => {
          console.log(res)
          let _bloglist = res.data
          for (let i = 0, len = _bloglist.length; i < len; i++) {
            _bloglist[i].createTime = _bloglist[i].createTime.toString()
          }
          this.setData({
            blogList: this.data.blogList.concat(_bloglist)
          })
  
          wx.hideLoading()
        })
  
    },
  ```


## 6.7生成小程序码

- 适用于需要码数量多的业务场景

- ```
  https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html#method-cloud
  ```

  编写小程序云函数之前在云函数文件夹新增config.json文件，加入配置

  ```
  {
    "permissions": {
      "openapi": [
        "wxacode.getUnlimited"
      ]
    }
  }
  ```

- 编写生成小程序码的云函数

- 调用cloud.openapi.wxacode.getUnlimited（）这个api后传入当前用户的openId可以返回一个包含小程序码的对象，其中小程序码是buffer字段，以二进制存在

- 之后吧这个buffer传入云存储，并返回一个fileId，这里的cloudPath: 'qrcode/' 相当于在云储存的qrcode文件夹下插入图片

- 最终把这个fileId传给前台

  ```javascript
  const cloud = require('wx-server-sdk')
  
  cloud.init()
  
  // 云函数入口函数
  exports.main = async(event, context) => {
    const wxContext = cloud.getWXContext()
    let result = await cloud.openapi.wxacode.getUnlimited({
      // scene:可见字符长度
      scene: wxContext.OPENID,
      // 修改小程序码周围发散图标夯实
      // lineColor: {
      //   'r':211,
      //   'g':60,
      //   'b':57
      // },
      // 是否需要透明底色
      // isHyaline: true
    })
    // 返回的结果包含一个buffer ,也就是小程序码的二进制格式
    console.log(result, 'result')
    // 把图片上传到云端并返回一个fileId
    const upload = await cloud.uploadFile({
      cloudPath: 'qrcode/' + Date.now() + '-' + Math.random() + '.png',
      // result.buffer表示二进制图片
      fileContent: result.buffer
    })
    console.log(upload,'upload')
    return upload.fileID
  }
  ```

- 前台调用云函数并得到返回值 fileId ，调用 wx.previewImage(Object object) 这个api可以预览当前的fileId也就是云ID对应的图片

- 因为只有一张图片，因此预览api的两个参数都一样

  ```javascript
    // 点击生成小程序码
    onTapQrCode() {
      wx.showLoading({
        title: '生成中~',
      })
      wx.cloud.callFunction({
        name: 'getQrCode'
      }).then(res => {
        console.log(res, '云结果')
        wx.previewImage({
          urls: [res.result],
          current: res.result
        })
        wx.hideLoading()
      })
    },
  ```

- 最后在生成小程序码的时候传入了scene，还可以写入page参数，表示用户点击小程序码跳转的页面，在这个页面的onload生命周期中，可以通过options.scene拿到生成时定义的参数

## 6.8模拟小程序更新操作

- 需要调用小程序api，并在app.js中的onLaunch使用，可以用添加编译模式来模拟更新操作

- 当用户点击确定就会自动重启

  ```javascript
    // 获取全局唯一的版本管理器
    checkUpdate() {
      const updateManager = wx.getUpdateManager()
      // 检测版本更新
      updateManager.onCheckForUpdate((res) => {
        console.log(res, '检查新版本')
        if (res.hasUpdate)
          updateManager.onUpdateReady(() => {
            wx.showModal({
              title: '更新提示',
              content: '新版本已经准备好，是否重启应用',
              success: (res) => {
                if (res.confirm) {
                  updateManager.applyUpdate()
                }
              }
            })
          })
      })
    }
  ```


## 6.9setData的一些操作补充

- 如果要设置某个对象里的某个属性。则应用以下语法

  ```
  this.setData({
      ['userInfo.nickName']:'张三'
  })
  ```


## 6.10场景值scene的作用和应用场景

- 在app.js的onLaunch 和 onShow 可以有一个options参数，可根据里面的scene判断用是根据何种方式进入小程序，我们可以根据场景来配置小程序